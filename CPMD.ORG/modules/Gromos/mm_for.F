C     ==--------------------------------------------------------------==
      SUBROUTINE FORCE(NATTOT,X,F,XR,XCEN,C4D,CW4D,
     $     ENER,ENERES,DEDLAM,DEDMU,EPEL,EPRF,EPRC,EPLJ,
     $     VIR,NSPM,NSP,NDR,
     $     IDR1,JDR1,KDR1,LDR1,ICDR1,
     $     IDR2,JDR2,KDR2,LDR2,ICDR2,
     $     R0,W0,DISH,DISC,RIIAVE,
     $     NRRST,JRC,CXC,XC,
     $     NDJV,IPJV, JPJV, KPJV, LPJV,
     $     CPJV,PJR0,PSJR,AJV,BJV,CJV,
     $     COSQAV,COSIAV,
     $     NDLR,IPLR,JPLR,KPLR,LPLR,ICPLR,
     $     CPLR,PDLR,
     $     NDLE,IPLE,JPLE,KPLE,LPLE,
     $     NLECFG,NLEMEM,ILEMEM,NLEVST,
     $     IAGRP,LEVERY,LERR,LFREE)
C     ==--------------------------------------------------------------==
COMMSUBR FORCE
C     W.F. VAN GUNSTEREN, GRONINGEN, JULY 1987
C     Id: force.f,v 1.39 1997/02/19 14:31:17 wscott Exp
Cmb - Revised on 17 October 2006
C
C     FORCE will supply forces and energies for a number of solute
C     (protein) molecules in vacuo, or in a (periodic) box with
C     solvent molecules.
C     If the virial is to be calculated, (ABS( L<NTB>) .EQ. L<NTBVIR>,
C     it must be specified whether the solute consists of separate
C     molecules(see L<NSP> and L<NSPM>).
C
C     FORCE can generate the following covalent force types:
C     force type             subroutine name
C     Covalent bond                 L<COBOND>
C     Path integral bond            L<COBOND>
C     Bond angle                    L<ANGLE>
C     improper (harmonic) dihedral  L<DIHANG>
C     sinusoidal dihedral           L<DIHANG>
C
C     Non bonded forces are calculated by calling
C     L<NBPML> to construct a pairlist. Long range (electrostatic and
C     Lennard-Jones) forces can also be calculated there.
C
C     L<NONBML> is called to calculate the non bonded forces using
C     a pairlist generated by L<NBPML>.
C
C     Other forces and energies calculated are:
C     force type
C     dihedral angle restraints     L<DIHANG>
C     distance restraints           L<DISRE>
C     position restraining          L<RESTX>
C     J-value restraining           L<RESTJ>
C     4th D restraining             L<FOURHA>
C     local elevation search        L<LESEAR>
C     
C     Aside from force calculation, FORCE can also monitor dihedral
C     transitions (see L<DIHMON>).
C
C     FORCE accesses a number of variables from common blocks:
C     L<NPM>           The number of solute molecules
C     L<NRP>           The number of atoms per solute molecule
C     L<NSM>           The number of solvent molecules
C     L<NRAM>          The number of atoms per solvent molecule
C     L<LTF>           Determines which forces are calculated.
C     L<NTPI>          Determines whether path integral interaction
C                      is calculated or not.
C
C     When the virial is to be calculated (ABS(L<NTB>) = L<NTBVIR>), 
C     the following variables are accessed:
C     L<NSPM>          Number of separate (sub)molecules forming
C                      one solute molecule.
C     L<NSP>           Atom sequence numbers of the last atoms of the
C                      submolecules.
C
C     Periodic boundary conditions can be applied, which is determined
C     by variables L<NTB>, L<BOX>, and L<BETA>.
C
C     The arguments to FORCE are:
C     NATTOT          the total number of atoms in the system.
C                     NATTOT must be NPM*NRP+NSM*NRAM
C     CW4D            the force constant used in the 4thD force
C                     calculation. This variable is only used
C                     if L<NDIM> > 3.
C     X(MAXXCO)       atom cartesian coordinates; X- and Y- axes lie
C                     along box edges.
C     F(MAXXCO)       delivered with forces.
C     XR(MAXXCO)      atom cartesian coordinates relative to the
C                     submolecular centres of mass. This array
C                     is only accessed if the virial is to be
C                     calculated.
C     Energy components are delivered in the following arrays according
C     to the interaction type, e.g. bond, bond angle,...
C     They are accessed using indices defined in forcesz.h.
C
C     ENER           is delivered with energy contributions
C     ENERES         is delivered with energy contributions. This
C                    array contains more esoteric values
C                    (e.g. the local elevation contribution) which do not
C                    have a lamda dependence.
C     DEDLAM         is delivered with the derivatives of the various
C                    terms of the Hamiltionian with respect to L<LAMDA>
C                    if L<NTG> = L<NTGLAM> or L<NTG> = L<NTGBOT>
C     DEDMU          is delivered with the derivatives of the various
C                    terms of the Hamiltonian with respect to L<RMU>
C                    if L<NTG> = L<NTGMU> or L<NTG> = L<NTGBOT>.
C
C     Non-bonded energy contributions in all subroutines called by FORCE
C     is divided up into potential energy between groups of atoms.
C     The groups are defined by the user at run-time (array  L<NRE>).
C     The individual contributions are delivered in the following
C     three arrays.
C     EPEL(MXNRE2)   the contributions due to Coulomb interactions
C     EPRF(MXNRE2)   the distance dependent 
C                    contributions due to the reaction field
C     EPRC(MXNRE2)   the distance independent
C                    contributions due to the reaction field
C     EPLJ(MXNRE2)   the contributions due to Lennard-Jones interactions
C
C     VIR(1..NDIM)   delivered with X-, Y- and Z components of the
C                    virial if ABS(L<NTB>) = L<NTBVIR>.
C
C     Atom position restraints and constraints are controlled by
C     the following arguments to FORCE and L<NTR> (see below).
C     NRRST            the number of position restraints
C     JRC(NRRST)       atom indices of the atoms to be restrained
C     Note: CONstraints are NOT implemented in FORCE, but in L<MDLEAP>
C     or L<SDLEAP>.
C     CXC(NATTOT)    force constants used in the position restraining.
C     XC(NDIM*NATTOT)the reference positions for re(con)straining.
C
C     Atom distance restraints are controlled by the following arguments
C     to L<FORCE> and by L<NTDR> in md.h.
C     See subr. L<DISRE>
C     NDR            the number of distance restraints
C     IDR1(NDR),JDR1(NDR),KDR1(NDR),LDR1(NDR),ICDR1(NDR)
C     IDR2(NDR),JDR2(NDR),KDR2(NDR),LDR2(NDR),ICDR2(NDR)
C     R0(NDR),W0(NDR)
C
C     C4D(NATTOT)    the force constants for the 4th D harmonic
C                    restraining term. The values are also tested by
C                    other routines in order to determine whether
C                    an atom is in 3 or 4D:
C                    IF C4D(I) .GE. 0.0 then I is in 4D. otherwise
C                    I is in 3D. This array is only used
C                    if L<NT4DIM> .NE.  L<NT4OFF>.
C     IAGRP(NATTOT)  a CHARACTER array which is used to specify
C                    the energy groups of atoms. See subroutines
C                    L<NBPML> and L<NONBML>.
C
C     LEVERY
C     .FALSE.  a number of quantities depending on BOX, BETA etc.
C              are only calculated at the first SUBR. call.
C     .TRUE.   they are calculated every SUBR. call.
C
C     LERR           delivered with .TRUE. if an error occurs
C                    in the subroutine.
C
C     Other arguments not passed as parameters influencing the behaviour
C     of L<FORCE> or subroutines called by FORCE
C     are defined in the file md.h:
C
C     L<NTR>     controls the re(con)straining:
C     L<NTROFF>: no position re(constraining)
C     L<NTRCHO>,L<NTRBFA>: position restraining, see subroutine L<RESTX>.
C     L<NTRCON>: position constraining. This is NOT achieved by
C     calling L<RESTX> as for restraining, but is implemented in the
C     integration of motion algorithms L<LEAPSD>, L<LEAPMD>.
C
C     L<NTDR> controls distance restraining (see subr. L<DISRE>)
C
C     L<LTNB> controls the generation of a nonbonded pairlist.
C
C     L<NT4DIM>
C            specifies whether the system is in three or four
C            dimensions.
C     ==--------------------------------------------------------------==
      IMPLICIT NONE
C includes
      INCLUDE 'coordsz.h'
      INCLUDE 'md.h'
      INCLUDE 'box.h'
      INCLUDE 'toposz.h'
      INCLUDE 'topoar.h'
      INCLUDE 'forcesz.h'
      INCLUDE 'forcear.h'
      INCLUDE 'cobond.h'
      INCLUDE 'restx.h'
      INCLUDE 'pertsz.h'
      INCLUDE 'pertar.h'
      INCLUDE 'disre.h'
      INCLUDE 'le.h'
      INCLUDE '../mm_input.inc'
C args
      INTEGER NATTOT, IFIRST
      LOGICAL LERR,LEVERY,LFREE
      CHARACTER IAGRP(NATTOT)
      real*8 X(NDIM*NATTOT),F(NDIM*NATTOT)
      real*8 XR(NDIM*NATTOT)
      real*8 C4D(NATTOT),CW4D

      real*8 EPLJ(*),EPRF(*)
      real*8 EPRF14(MXNRE2),EPRC(*),EPEL(*)
      real*8 ENER(MXETBL),DEDLAM(MXETBL),DEDMU(MXETBL)
      real*8 ENERES(MXCTBL)

      real*8 VIR(NDIM)
C distance restraint args
      INTEGER NDR
      INTEGER IDR1(NDR),JDR1(NDR),KDR1(NDR),LDR1(NDR),ICDR1(NDR)
      INTEGER IDR2(NDR),JDR2(NDR),KDR2(NDR),LDR2(NDR),ICDR2(NDR)
      real*8    R0(NDR),W0(NDR),DISH,DISC
      real*8 RIIAVE(NDR)
C submolecule defs
      INTEGER NSPM,NSP(NSPM)
C position re(con)straints
      INTEGER NRRST
      INTEGER JRC(NRRST)
      real*8 CXC(NATTOT),XC(NDIM*NATTOT)

C jvalue restraining
      INTEGER NDJV
      INTEGER IPJV(NDJV), JPJV(NDJV), KPJV(NDJV), LPJV(NDJV)
      real*8    CPJV(NDJV),PJR0(NDJV),PSJR(NDJV)
      real*8    AJV(NDJV),BJV(NDJV),CJV(NDJV)
      real*8    COSQAV(NDJV),COSIAV(NDJV)

C dihedral restraints
      INTEGER NDLR
      INTEGER IPLR(NDLR),JPLR(NDLR),KPLR(NDLR),LPLR(NDLR),ICPLR(NDLR)
      real*8 CPLR(NDLR),PDLR(NDLR)

C local elevation
      INTEGER NDLE,NLECFG,NLEMEM
      INTEGER IPLE(NDLE),JPLE(NDLE),KPLE(NDLE),LPLE(NDLE)
      INTEGER ILEMEM(MXLECF,NLEMEM),NLEVST(NLEMEM)
C local vars
      INTEGER NATTO3,NRAGT,NRAGT3,I,IDUM,NRPT,IATCO
      INTEGER ILEPOT
      SAVE    ILEPOT
      INTEGER J,K
      CHARACTER PRGSTR*(5)
      LOGICAL LDOVIR,LDOPER,LDO34D
      SAVE    LDOVIR,LDOPER,LDO34D

      LOGICAL LFIRST
      SAVE    LFIRST
C
      real*8 XDUM,EDUM,ETMPEL,ETMPRF,ETMPRC,ETMPLJ
      real*8 ETMP1,ETMP2
C----
C long range variables. These have to be saved
      LOGICAL LGOTLR
      SAVE    LGOTLR
      real*8 VIRLR(MAXDIM)
      SAVE VIRLR
      real*8, allocatable :: CGT(:),FLR(:)
      SAVE CGT,FLR

      real*8 ESELF,ERCOR

      real*8 ELREL(MXNRE2),ELGLEL,EL34EL
      real*8 ELRRF(MXNRE2),ELGLRF,EL34RF
      real*8 ELRRC(MXNRE2),ELGLRC,EL34RC
      real*8 ELRLJ(MXNRE2),ELGLLJ,EL34LJ

      SAVE ELREL,ELGLEL,EL34EL
      SAVE ELRRF,ELGLRF,EL34RF
      SAVE ELRRC,ELGLRC,EL34RC
      SAVE ELRLJ,ELGLLJ,EL34LJ

C path integral
      LOGICAL LDOPIN
      SAVE    LDOPIN

C pairlist variables
      INTEGER NSZJNB
      INTEGER, POINTER :: INB(:)
      INTEGER, POINTER :: JNB(:)
      common/saveplist/NSZJNB,INB,JNB 
C
      LOGICAL L34LOC
      real*8 RMUTMP

C data
      DATA LFIRST /.TRUE./
      DATA LGOTLR /.FALSE./
      DATA PRGSTR /'FORCE'/
C
C arg
      real*8 XCEN(3*(NPM*NSPM+NSM))
      real*8 ht_to_kj,scale
      parameter(ht_to_kj=2.6255000195D3)   
C local
      LOGICAL LEWALD
      LOGICAL LPPPM

      DATA IFIRST /0/
C begin
C Phil
      LEWALD = (NLATSM.EQ.NEWALD)
      LPPPM = (NLATSM.EQ.NPPPM)
#ifndef EWALD
      IF (LEWALD .OR. LPPPM) THEN
        WRITE(6,*)'EWALD OR PPPM SELECTED, BUT'
        WRITE(6,*)'THE CODE WAS NOT COMPILED WITH -DEWALD'
        CALL STOPGM('FORCE','FATAL ERROR')
      ENDIF
#ifdef EWATCUT
      WRITE(6,*)'WARNING: THE CODE WAS COMPILED WITH -DEWATCUT'
      WRITE(6,*)'BUT NOT -DEWALD'
C      CALL STOPGM('FORCE','FATAL ERROR')
#endif
#else
      IF (.NOT.LEWALD .AND. .NOT.LPPPM) THEN
        WRITE(6,*)'EWALD OR PPPM NOT SELECTED, BUT'
        WRITE(6,*)'THE CODE WAS COMPILED WITH -DEWALD'
        CALL STOPGM('FORCE','FATAL ERROR')
      ENDIF
#endif

      NATTO3 = NDIM*NATTOT
      NRAGT = NPM*NCAG + NSM
      NRAGT3 = NDIM*NRAGT
      NRPT = NPM*NRP

      XDUM = 0.0D0  ! cmb-default

      LERR = .FALSE.
      LDOVIR = (ABS(NTB) .EQ. NTBVIR)
      LDOPER = (NTG .EQ. NTGLAM .OR. NTG .EQ. NTGBOT)
      LDO34D = (NTG .EQ. NTGMU  .OR. NTG .EQ. NTGBOT)

      IF (LFIRST) THEN
         LFIRST = .FALSE.

         allocate(CGT(MAXNAT),FLR(MAXXCO))
         allocate(INB(MAXINB),JNB(MAXJNB))
C     path integral
         LDOPIN = (NTPI .EQ. NTPION)
C local elevation
         IF (NTLE .EQ. NTLEGS) THEN
            ILEPOT = ILEGAU
         ELSEIF (NTLE .EQ. NTLEQU) THEN
            ILEPOT = ILEIVQ
         ENDIF

C
C***** MAKE CHARGE VECTOR OF THE WHOLE SYSTEM, ATOM BY ATOM
C     
        K = 0
        DO I = 1, NPM
          DO J = 1, NRP
            K = K + 1
            CGT(K) =  CG(J)
          ENDDO
        ENDDO
!$OMP parallel do private(I,J) shared(K)
        DO I = 1, NRAM
          DO J = I, NSM*NRAM, NRAM
            CGT(K+J) = CGS(I)
          ENDDO
        ENDDO
C
C end if lfirst
      ENDIF

C check limits of charge groups
      IF (NRAGT .GT. MAXINB) THEN
         WRITE(6,*)PRGSTR,': TOO MANY CHARGE GROUPS PLUS ',
     .        'SOLVENT MOLECULES!'
         WRITE(6,*)'NRAGT = ',NRAGT
         WRITE(6,*)'MAXINB= ',MAXINB
         WRITE(6,*)'CHANGE MAXINB IN YOUR INPUT FILE TO',
     .             ' MAXINB >= NRAGT'
         WRITE(6,*)
         LERR = .TRUE.
         RETURN
      ENDIF

C make a pairlist if required
      IF (LTNB .AND. LTF(NTFNBN)) THEN
         RMUTMP = RMU
         L34LOC = LDO34D
C     we must pass RMU = 0.0  and 
C     LDO34D = .FALSE. to nonbml if we have NCALCD=3
         IF (NDO4D(N4DNBD) .EQ. NDRMAX) THEN
            RMUTMP = 0.0D0
            L34LOC = .FALSE.
         ENDIF

         CALL NBPML(NATTOT,NPM,NSM,NRAGT,NDO4D(N4DNBD),
     $        X,F,XR,FLR,
     $        NSPM,NSP,VIRLR,
     $        INB,NSZJNB,JNB,RCUTP,RCUTL,
     $        MAXNRE,NRELKP,IAGRP,
     $        RCRF,EPSRF,APPAK,
     $        ELGLEL,ELGLRF,ELGLRC,ELGLLJ,
     $        EL34EL,EL34RF,EL34RC,EL34LJ,
     $        NUNRE2,ELREL,ELRRF,ELRRC,ELRLJ,
     $        LDOPER, L34LOC,
     $        RLAM,RMUTMP,ALPHLJ,ALPHC,NLAM,MMU,
     $        NTPI .EQ. NTPION,LEVERY,LFREE)

         LGOTLR = (RCUTL .GT. RCUTP)
      ENDIF

C set force and energies to zero
C do this here as F might have been used 
C temporarily in the pairlist calculation (see nbpml).
      CALL mm_AZZERO(F,NATTO3)
      
C init the energies
!$OMP parallel do private(I)
#ifdef __SR11000
*poption parallel, tlocal(I)
#endif
      DO I=1,MXETBL
         ENER(I)   = 0.0D0
         DEDLAM(I) = 0.0D0
         DEDMU(I)  = 0.0D0
      ENDDO
C
      CALL mm_AZZERO(ENERES,MXCTBL)
!
C init virial array 
      IF (LDOVIR) THEN
         CALL mm_AZZERO(VIR,NDIM)
      ENDIF

C calc nonbonded interactions if required
      IF (LTF(NTFNBN)) THEN
C use cg/molecular pairlist
         RMUTMP = RMU
         L34LOC = LDO34D
C we must pass RMU = 0.0 and
C LDO34D = .FALSE. to nonbml if we have NCALCD=3
         IF (NDO4D(N4DNBD) .EQ. NDRMAX) THEN
            RMUTMP = 0.0D0
            L34LOC = .FALSE.
         ENDIF
!
C Do the lattice-sum computations...
        IF (LEWALD .OR. LPPPM) THEN
          scale=1.d0 ! AKM
          IF (LEWALD) THEN
            CALL KWALD(NATTOT,NPM,NRP,NSM,NRAM,CG,CGS,X,F,
     .           EKWALD,ALPHA,KXMAX,KYMAX,KZMAX,K2MAX,BOX)
            CALL KWCOR(NATTOT,NDIM,NPM,NRP,NRAM,NCAG,NRAGT,
     .           INE,JSNE,KNE,IAGRP,MAXNRE,NRELKP,CG,CGS,
     .           ALPHA,BOX,X,NUNRE2,EPRC,EPRF,F,scale)
          ELSE
            CALL KPPPM (NATTOT,CGT,X,F,EKWALD,ERCOR,
     .           ESELF,ALPHA,KXMAX,KYMAX,KZMAX,BOX)
!
            CALL KWCOR(NATTOT,NDIM,NPM,NRP,NRAM,NCAG,NRAGT,
     .           INE,JSNE,KNE,IAGRP,MAXNRE,NRELKP,CG,CGS,
     .           ALPHA,BOX,X,NUNRE2,EPRC,EPRF,F,scale)
!
            IF(qmmm_amber) THEN
              scale=1.d0-scale_14_amber
              CALL mm_AZZERO(EPRF14,MXNRE2)
C ES: instead of NRAM, 0 is passed in order to prevent
C ES: double counting the solvent solvent interaction
              CALL KWCOR(NATTOT,NDIM,NPM,NRP,0,NCAG,NRAGT,
     .           INE14,JSNE14,KNE14,IAGRP,MAXNRE,NRELKP,CG,CGS,
     .           ALPHA,BOX,X,NUNRE2,EPRC,EPRF14,F,scale)
!$OMP parallel do private(I)
#ifdef __SR11000
*poption parallel, tlocal(I)
#endif
              DO I=1,MXNRE2
                EPRF(I)=EPRF(I)+EPRF14(I)
              ENDDO
            ENDIF

          ENDIF
          ENER(IPKW) = EKWALD
C
C ERC is recycled to contain the self term - only calculated in the first
C call to KWCOR.
C ERF is recycled to contain the exclusion correction.
C Make sure these are not touched in nonbml (or any other routine) !
C
        ENDIF
!

C FIXME: AK 2005/05/17 clean up this preprocessor monstrosity.
C                      and have just 3 different subroutines.
      CALL NONBML(NATTOT,NPM,NRAGT,NDO4D(N4DNBD),X,F,
     $     XR,
#ifdef EWALD
     $       ALPHA,
#endif
#ifdef EWATCUT
     $       RCUTP,
#endif
     $        NSPM,NSP,VIR,
     $        INB,NSZJNB,JNB,
     $        MAXNRE,NRELKP,IAGRP,
     $        RCRF,EPSRF,APPAK,
     $        DEDLAM(IPEL),DEDLAM(IPRF),DEDLAM(IPRC),DEDLAM(IPLJ),
     $        DEDMU(IPEL),DEDMU(IPRF),DEDMU(IPRC),DEDMU(IPLJ),
     $        NUNRE2,EPEL,EPRF,EPRC,EPLJ,
     $        LDOPER, L34LOC,
     $        RLAM,RMUTMP,ALPHLJ,ALPHC,NLAM,MMU,
     $        NTPI .EQ. NTPION,LEVERY,LFREE)

         IF (LDOPER .AND. NEB .GT. 0 ) THEN
!           CALL NONBPL(NATTOT,NPM,NDO4D(N4DNBD),X,F,XR,
!    $           NSPM,NSP,VIR,
!    $           MAXNRE,NRELKP,IAGRP,
!    $           RCRF,EPSRF,APPAK,
!    $           DEDLAM(IPEL),DEDLAM(IPRF),DEDLAM(IPRC),DEDLAM(IPLJ),
!    $           DEDMU(IPEL),DEDMU(IPRF),DEDMU(IPRC),DEDMU(IPLJ),
!    $           NUNRE2,EPEL,EPRF,EPRC,EPLJ,
!    $           L34LOC,
!    $           RLAM,RMUTMP,ALPHLJ,ALPHC,NLAM,MMU,
!    $           LEVERY)
         ENDIF

C add r-space correction
            EPEL(1) = EPEL(1)+ERCOR
C include Wigner self term
            EPRC(1) = ESELF
C
      ENDIF

C improper dihedrals with H atoms
C NOTE: improper dihedrals are always calculated in three dims,
C even if NDIM = 4
C
      IF (LTF(NTFIDH) .AND. NQHIH .GT. 0) THEN
         ETMP1 = 0.0D0
         ETMP2 = 0.0D0
         CALL DIHANG(3,NPM,NRP,NFEF,IDINCS,LEVERY,
     $        NQHIH,IQH,JQH,KQH,LQH,ICQH,
     $        NQTY,CQ,Q0,IDUM,
     $        NRPT,X,F,ETMP1,XDUM,EDUM,
     $        .FALSE.,RLAM,0,XDUM,XDUM,XDUM,XDUM,IDUM,IDUM,EDUM,
     $        .FALSE.,RMU,XDUM,EDUM)

         IF (LDOPER .AND. NQHIHG .GT. 0) THEN
            CALL DIHANG(3,NPM,NRP,NFEF,IDINCS,LEVERY,
     $           NQHIHG,IQHG,JQHG,KQHG,LQHG,IDUM,
     $           0,XDUM,XDUM,IDUM,
     $           NRPT,X,F,ETMP2,XDUM,EDUM,
     $           .TRUE.,RLAM,NQHIHG,CQHA,CQHB,QHA0,QHB0,IDUM,IDUM,
     $           DEDLAM(IPQH),
     $           .FALSE.,RMU,XDUM,EDUM)
         ENDIF
         ENER(IPQH) = ETMP1 + ETMP2
      ENDIF
!
C improper dihedrals without H-atoms
      IF (LTF(NTFIDE) .AND. NQHI .GT. 0)THEN
         ETMP1 = 0.0D0
         ETMP2 = 0.0D0
         CALL DIHANG(3,NPM,NRP,NFEF,IDINCS,LEVERY,
     $        NQHI,IQ,JQ,KQ,LQ,ICQ,
     $        NQTY,CQ,Q0,IDUM,
     $        NRPT,X,F,ETMP1,XDUM,EDUM,
     $        .FALSE.,RLAM,0,XDUM,XDUM,XDUM,XDUM,IDUM,IDUM,EDUM,
     $        .FALSE.,RMU,XDUM,EDUM)
!
         IF (LDOPER .AND. NQHIG .GT. 0) THEN
            CALL DIHANG(3,NPM,NRP,NFEF,IDINCS,LEVERY,
     $           NQHIG,IQG,JQG,KQG,LQG,IDUM,
     $           0,XDUM,XDUM,IDUM,
     $           NRPT,X,F,ETMP2,XDUM,EDUM,
     $           .TRUE.,RLAM,NQHIG,CQA,CQB,QA0,QB0,IDUM,IDUM,
     $           DEDLAM(IPQE),
     $           .FALSE.,RMU,XDUM,EDUM)
         ENDIF
         ENER(IPQE) = ETMP1 + ETMP2
      ENDIF
!
C other contributions
!
C bonds with H atoms
      IF (LTF(NTFBNH) .AND. NBONH .GT. 0) THEN
         CALL BONDS(NDO4D(N4DBON),NPM,NRP,LEVERY,
     $        NBONH,IBH,JBH,ICBH,
     $        NBTY,CB,B0,
     $        NRPT,X,F,ENER(IPBH),
     $        LDOPER,RLAM,NBONHG,IBHG,JBHG,CBHA,CBHB,
     $        BHA0,BHB0,DEDLAM(IPBH),
     $        LDO34D,RMU,C4D,DEDMU(IPBH))
      ENDIF
C bonds without H atoms
      IF (LTF(NTFBND) .AND. NBON .GT. 0) THEN
         CALL BONDS(NDO4D(N4DBON),NPM,NRP,LEVERY,
     $        NBON,IB,JB,ICB,
     $        NBTY,CB,B0,
     $        NRPT,X,F,ENER(IPBN),
     $        LDOPER,RLAM,NBONG,IBG,JBG,CBA,CBB,BA0,BB0,DEDLAM(IPBN),
     $        LDO34D,RMU,C4D,DEDMU(IPBN))
      ENDIF
C path integral 'bonds'
      IF (LDOPIN .AND. NPIB .GT. 0) THEN
         ETMP1 = 0.0D0
         ETMP2 = 0.0D0
         CALL COBOND(3,NPM,NRP,NFEF,IBND2,LEVERY,
     $        NPIB,IPIB,JPIB,ICPIB,
     $        NPIT,CPI,B0,
     $        NRPT,X,F,ETMP1,XDUM,EDUM,
     $        .FALSE.,RLAM,0,XDUM,XDUM,XDUM,XDUM,XDUM,
     $        .FALSE.,RMU,XDUM,EDUM)
         IF (LDOPER .AND. NBONG .GT. 0)THEN
            CALL COBOND(3,NPM,NRP,NFEF,IBND2,LEVERY,
     $           0,IDUM,IDUM,IDUM,
     $           0,XDUM,XDUM,
     $           NRPT,X,F,ETMP2,XDUM,EDUM,
     $           .TRUE.,RLAM,NBONG,CPIA,CPIB,BA0,BB0,DEDLAM(IPPISP),
     $           .FALSE.,RMU,XDUM,EDUM)
         ENDIF
         ENER(IPPISP) = ETMP1 + ETMP2
      ENDIF
C bond angles with H atoms
      IF (LTF(NTFANH) .AND. NTHEH .GT. 0) THEN
         CALL ANGLES(NDO4D(N4DBAN),NPM,NRP,LEVERY,
     $        NTHEH,ITH,JTH,KTH,ICTH,
     $        NTTY,CT,T0,
     $        NRPT,X,F,ENER(IPBAH),
     $        LDOPER,RLAM,NTHEHG,ITHG,JTHG,KTHG,
     $        CTHA,CTHB,THA0,THB0,DEDLAM(IPBAH),
     $        LDO34D,RMU,C4D,DEDMU(IPBAH))
      ENDIF
C bond angles without H atoms
      IF (LTF(NTFANG) .AND. NTHE .GT. 0) THEN
         CALL ANGLES(NDO4D(N4DBAN),NPM,NRP,LEVERY,
     $        NTHE,IT,JT,KT,ICT,
     $        NTTY,CT,T0,
     $        NRPT,X,F,ENER(IPBA),
     $        LDOPER,RLAM,NTHEG,ITG,JTG,KTG,
     $        CTA,CTB,TA0,TB0,DEDLAM(IPBA),
     $        LDO34D,RMU,C4D,DEDMU(IPBA))
      ENDIF
C dihedrals with H atoms
      IF (LTF(NTFDHH) .AND. NPHIH .GT. 0) THEN
         CALL DIHDLS(NDO4D(N4DDIH),NPM,NRP,LEVERY,
     $        NPHIH,IPH,JPH,KPH,LPH,ICPH,
     $        NPTY,CP,PD,NP,
     $        NRPT,X,F,ENER(IPPH),
     $        LDOPER,RLAM,NPHIHG,IPHG,JPHG,KPHG,LPHG,
     $        CPHA,CPHB,PDHA,PDHB,
     $        NPHA,NPHB,DEDLAM(IPPH),
     $        LDO34D,RMU,C4D,DEDMU(IPPH))
      ENDIF
C dihedrals without H atoms
      IF (LTF(NTFDIH) .AND. NPHI .GT. 0) THEN
         CALL DIHDLS(NDO4D(N4DDIH),NPM,NRP,LEVERY,
     $        NPHI,IP,JP,KP,LP,ICP,
     $        NPTY,CP,PD,NP,
     $        NRPT,X,F,ENER(IPPE),
     $        LDOPER,RLAM,NPHIG,IPG,JPG,KPG,LPG,CPA,CPB,PDA,PDB,
     $        NPA,NPB,DEDLAM(IPPE),
     $        LDO34D,RMU,C4D,DEDMU(IPPE))
      ENDIF
CCC monitor dihedral transitions if required
      IF (NTPP .EQ. NTPPYE)THEN
         CALL DIHMON(NRPT,NPM,X)
      ENDIF
CCC dihedral angle restraining if required (This is always in 3D)
      IF (NTDLR .NE. NTDLRN) THEN
         CALL DIHANG(NDRMAX,NPM,NRP,NFEF,IDINCS,LEVERY,
     $        NDLR,IPLR,JPLR,KPLR,LPLR,ICPLR,
     $        NDLR,CPLR,PDLR,IDUM,
     $        NRPT,X,F,ENERES(ICDHRE),XDUM,EDUM,
     $        .FALSE.,RLAM,0,XDUM,XDUM,XDUM,XDUM,IDUM,IDUM,EDUM,
     $        .FALSE.,RMU,XDUM,EDUM)
      ENDIF
CCC calculate distance restraint energy
cmb      IF (NTDR .NE. NTDROF) THEN
!        CALL DISRE(NATTOT,NDR,NDO4D(N4DRST),NDREF,
!    $        DT,X,F,RIIAVE,
!    $        IDR1,JDR1,KDR1,LDR1,ICDR1,
!    $        IDR2,JDR2,KDR2,LDR2,ICDR2,
!    $        DISH,DISC,NPM,NRP,W0,R0,DR0,
!    $        ENERES(ICDISR),XDUM,EDUM,
!    $        NTDR .LT. 0,TAUDR,LRDDR,LEVERY)
cmb      ENDIF

CCC calculate position restraint energy
      IF (NTR .NE. NTROFF .AND. NTR .NE. NTRCON) THEN
        CALL RESTX(NRRST,NATTOT,JRC,CXC,XC,X,F,ENERES(ICPOSR),
     $        NFREF,XDUM,EDUM,LEVERY)
      ENDIF

CCC calculate J-value restraint energy
cmb      IF (NTJR .NE. NTJROF) THEN
!        CALL RESTJ(NPM,NRP,(NTJRH .EQ. NTJRHH),(NTJR .LT. 0),TAUJR,DT,
!    $        ENERES(ICJVAL),X,F,
!    $        NDJV,IPJV, JPJV, KPJV, LPJV,
!    $        CPJV,PJR0,PSJR,AJV,BJV,CJV,
!    $        COSQAV,COSIAV,
!    $        LEVERY)
cmb      ENDIF

CC calculate 4th D restraining energy if required
cmb      IF (NT4DIM .NE. NT4OFF .AND. NDO4D(N4DHAR) .EQ. NDIM) THEN
!        CALL FOURHA(NATTOT,NDIM,CW4D,C4D,X,F,ENERES(ICRE4D))
cmb      ENDIF

CCC local elevation if required
cmb      IF (NTLE .NE. NTLEOF) THEN
!        CALL LESEAR(NRP,NDIM,ILEPOT,NRDLE .EQ. NRDLEY,
!    $        CWLE,X,F,
!    $        NDLE,IPLE,JPLE,KPLE,LPLE,
!    $        ENERES(ICLOCE),
!    $        NLECFG,NLEMEM,ILEMEM,NLEVST,
!    $        LEVERY)
cmb      ENDIF
!
C now add in all long range coulomb contributions
      IF (LGOTLR) THEN
!$OMP parallel do private(I)
#ifdef __SR11000
*poption parallel, tlocal(I)
#endif
         DO I=1,MXNRE2
            EPEL(I) = EPEL(I) + ELREL(I)
            EPRF(I) = EPRF(I) + ELRRF(I)
            EPRC(I) = EPRC(I) + ELRRC(I)
            EPLJ(I) = EPLJ(I) + ELRLJ(I)
         ENDDO

         DEDLAM(IPEL) = DEDLAM(IPEL) + ELGLEL
         DEDLAM(IPRF) = DEDLAM(IPRF) + ELGLRF
         DEDLAM(IPRC) = DEDLAM(IPRC) + ELGLRC
         DEDLAM(IPLJ) = DEDLAM(IPLJ) + ELGLLJ

         DEDMU(IPEL) = DEDMU(IPEL) + EL34EL
         DEDMU(IPRF) = DEDMU(IPRF) + EL34RF
         DEDMU(IPRC) = DEDMU(IPRC) + EL34RC
         DEDMU(IPLJ) = DEDMU(IPLJ) + EL34LJ
C
!$OMP parallel do private(I)
#ifdef __SR11000
*poption parallel, tlocal(I)
#endif
         DO I=1,NATTO3
            F(I) = F(I) + FLR(I)
         ENDDO
C
         IF (LDOVIR) THEN
!$OMP parallel do private(I)
#ifdef __SR11000
*poption parallel, tlocal(I)
#endif
            DO I=1,NDIM
               VIR(I) = VIR(I)+ VIRLR(I)
            ENDDO
         ENDIF
      ENDIF
C
C now for LJ, Coulomb and reaction field contribution types, add up total
      ETMPEL = 0.0D0
      ETMPRF = 0.0D0
      ETMPRC = 0.0D0
      ETMPLJ = 0.0D0
!$OMP parallel do private(I) reduction(+:ETMPEL,ETMPRF,ETMPRC,ETMPLJ)
#ifdef __SR11000
*poption parallel, tlocal(I)
*poption psum(ETMPEL,ETMPRF,ETMPRC,ETMPLJ)
#endif
      DO I=1,NUNRE2
         ETMPEL = ETMPEL + EPEL(I)
         ETMPRF = ETMPRF + EPRF(I)
         ETMPRC = ETMPRC + EPRC(I)
         ETMPLJ = ETMPLJ + EPLJ(I)
      ENDDO
      ENER(IPEL) = ETMPEL
      ENER(IPRF) = ETMPRF
      ENER(IPRC) = ETMPRC
      ENER(IPLJ) = ETMPLJ
cmb
      IF(qmmm_verbose) THEN
      WRITE(6,'('' MM ENERGY CONTRIBUTIONS:'')')
      WRITE(6,'('' COULOMB INTERACTION         ='',f20.8)')ENER(IPEL)
      WRITE(6,'('' REACTION FIELD DIST. DEP.   ='',f20.8)')ENER(IPRF)
      WRITE(6,'('' REACTION FIELD DIST. INDEP. ='',f20.8)')ENER(IPRC)
      WRITE(6,'('' LENNARD-JONES INTERACTION   ='',f20.8)')ENER(IPLJ)
      ENDIF
cmb
C calc total potential energy and
C 'derived' energies, like total bond nrg and such like
      CALL CLCDRE(ENER)
      ETMP1 = 0.0D0
!$OMP parallel do private(I) reduction(+:ETMP1)
#ifdef __SR11000
*poption parallel, tlocal(I)
*poption psum(ETMP1)
#endif
      DO I=1,MXCTBL
         ETMP1 = ETMP1 + ENERES(I)
      ENDDO
      ENER(IPTOT) = ENER(IPTOT) + ETMP1
      ENER(IPSPEC)= ETMP1
!
      IF (LDOPER) THEN
         CALL CLCDRE(DEDLAM)
      ENDIF
      IF (LDO34D) THEN
         CALL CLCDRE(DEDMU)
      ENDIF
!
C if we are in 4D, set the 4D components of atoms in 3D to 0.0
      IF (NT4DIM .NE. NT4OFF) THEN
!$OMP parallel do private(I,IATCO) shared(NDIM)
         DO I = 1,NATTOT
            IF (C4D(I).LT.0.0D0) THEN
               IATCO=I*NDIM
               F(IATCO) = 0.0D0
            ENDIF
         ENDDO
      ENDIF
C end force
C     ==--------------------------------------------------------------==
      RETURN
      END
C     ==================================================================
      SUBROUTINE CLCDRE(ENER)
C     ==--------------------------------------------------------------==
COMMSUBR CLCDRE
C     SUBROUTINE CLCDRE(ENER)
C
C     CLCDRE adds up the contributions in ENER to get some "derived"
C     values in the array. E.G., the total potential energy is calculated
C     and saved in ENER(IPTOT).
C     See forcesz.h for indices used in accessing ENER.
C     ==--------------------------------------------------------------==
      INCLUDE 'coordsz.h'
      INCLUDE 'forcesz.h'
C arg
      real*8 ENER(MXETBL)
C local vars
      real*8 ETMP
      INTEGER I
C begin
C calc total potential energy
C NOTE: THE ENERES CONTRIBUTIONS ARE STILL MISSING HERE!!!
      ETMP = 0.0D0
!$OMP parallel do private(I) reduction(+:ETMP)
#ifdef __SR11000
*poption parallel, tlocal(I)
*poption psum(ETMP)
#endif
      DO I=MNCONT,MXCONT
         ETMP = ETMP + ENER(I)
      ENDDO
C IPTOT has "special forces" energies added later on.
C IPIPSP stays as total potential energy without "special forces".
      ENER(IPTOT) = ETMP
      ENER(IPIPSP)= ETMP

cmb-dbg
!      write(6,*)'ENER(IPBH) =',ENER(IPBH)
!      write(6,*)'ENER(IPBN) =',ENER(IPBN)
!      write(6,*)'ENER(IPBAH) =',ENER(IPBAH)
!      write(6,*)'ENER(IPBA) =',ENER(IPBA)
!      write(6,*)'ENER(IPQH) =',ENER(IPQH)
!      write(6,*)'ENER(IPQE) =',ENER(IPQE)
!      write(6,*)'ENER(IPPH) =',ENER(IPPH)
!      write(6,*)'ENER(IPPE) =',ENER(IPPE)
!      write(6,*)'ENER(IPEL) =',ENER(IPEL)
!      write(6,*)'ENER(IPRF) =',ENER(IPRF)
!      write(6,*)'ENER(IPRC) =',ENER(IPRC)
!      write(6,*)'ENER(IPKW) =',ENER(IPKW)
!      write(6,*)'ENER(IPELEC) =',ENER(IPELEC)
!      write(6,*)'ENER(IPLJ) =',ENER(IPLJ)
cmb-dbg

      ENER(IPBTOT) = ENER(IPBH) +ENER(IPBN)
      ENER(IPBATO) = ENER(IPBAH)+ENER(IPBA)
      ENER(IPQTOT) = ENER(IPQH) +ENER(IPQE)
      ENER(IPPTOT) = ENER(IPPH) +ENER(IPPE)

      ENER(IPHTOT) = ENER(IPBH)+ENER(IPBAH)+
     .               ENER(IPQH)+ENER(IPPH)
      ENER(IPNHTO) = ENER(IPBN)+ENER(IPBA) +
     .               ENER(IPQE)+ENER(IPPE)

      ENER(IPCOVT) = ENER(IPHTOT)+ENER(IPNHTO)

#ifdef EWALD
      ENER(IPELEC) = ENER(IPEL)+ENER(IPRF)+ENER(IPRC)+ENER(IPKW)
#else
      ENER(IPELEC) = ENER(IPEL)+ENER(IPRF)+ENER(IPRC)
#endif
      ENER(IPNBON) = ENER(IPELEC) + ENER(IPLJ)
C end CLCDRE
C     ==--------------------------------------------------------------==
      RETURN
      END
C     ==================================================================
      SUBROUTINE DIHMON(NRPT,NPM,X)
C     ==--------------------------------------------------------------==
COMMSUBR DIHMON
C     SUBROUTINE DIHMON(NRPT,NPM,X)
C
C     DIHMON performs dihedral angle transition monitoring
C     for all solute dihedrals not involving H-atoms.
C
C     Each time a dihedral angle moves from one local minimum in the
C     dihedral interaction function to another, a message
C     is printed to screen.
C     ==--------------------------------------------------------------==
      INCLUDE 'coordsz.h'
      INCLUDE 'toposz.h'
      INCLUDE 'topoar.h'
      INCLUDE 'box.h'
      INCLUDE 'cobond.h'
C args
      INTEGER NRPT,NPM
      real*8 X(NRPT*NDIM)
C local vars
      LOGICAL LFIRST,LTIT
      SAVE LFIRST

C     the angles and the energies of each angle
      real*8 ANGLE(MXDMON),EANGLE(MXDMON)
C     this is used to store the reference angles over invocations
      real*8 WIDTH(MXDMON),PREFAN(MXDMON)
      SAVE WIDTH,PREFAN
C
      INTEGER N,ND,M,ICPP,NDUM
      INTEGER IAT,JAT,KAT,LAT,MM
      real*8 FDUM,XDUM,EDA,CURANG,CURWID,WID2
      real*8 RMULT,GESMIN,DIFFAN,DIFTMP
C
      CHARACTER TSTR*(MXNLE4)
      CHARACTER IJKSTR*(MXNLE4)
      CHARACTER PSTR*(MXNLE4)
C data
      DATA LFIRST /.TRUE./
C begin
C call DIHANG to get the current angles.
C these are returned in degrees in array ANGLE.
      CALL DIHANG(NDRMAX,NPM,NRP,NFEL,IDICOS,.FALSE.,
     $     NPHI,IP,JP,KP,LP,ICP,
     $     NPTY,CP,PD,NP,
     $     NRPT,X,FDUM,EDA,ANGLE,EANGLE,
     $     .FALSE.,XDUM,0,XDUM,XDUM,XDUM,XDUM,NDUM,NDUM,XDUM,
     $     .FALSE.,XDUM,XDUM,XDUM)

      IF (LFIRST) THEN
         LFIRST = .FALSE.
         M = 0
         DO 100 N = 1,NPM
            DO 30 ND = 1,NPHI
               M = M + 1
               CURANG = ANGLE(M)
C find the minimum we are in, depending on multiplicity
               ICPP = ICP(ND)
               RMULT = NP(ICPP)
               CURWID= 360.0D0/RMULT
               WID2  = CURWID*0.5D0

C first guess: first minimum, taking phase shift into account
               IF (DABS(PD(ICPP)-1.0D0).LT.1.0D-02) THEN
                  GESMIN = WID2
               ELSE
                  GESMIN = 0.0D0
               ENDIF

               DIFFAN = CURANG - GESMIN
               IF (DIFFAN.GT.180.0D0) THEN
                  DIFFAN=DIFFAN-360.0D0
               ELSEIF (DIFFAN.LT.-180.0D0) THEN
                  DIFFAN=DIFFAN+360.0D0
               ENDIF
C     find the minimum we are in (GESMIN)
C     while minimum not found
 55            IF (DABS(DIFFAN).GT.WID2) THEN
                  GESMIN = GESMIN + CURWID

                  DIFFAN = CURANG - GESMIN
                  IF (DIFFAN.GT.180.0D0) THEN
                     DIFFAN=DIFFAN-360.0D0
                  ELSEIF (DIFFAN.LT.-180.0D0) THEN
                     DIFFAN=DIFFAN+360.0D0
                  ENDIF
                  GOTO 55
               ENDIF
C end while
               PREFAN(M) = GESMIN
               WIDTH(M)  = CURWID
 30         CONTINUE
 100     CONTINUE
      ELSE
C     compare our current angles with the 
C     previously saved angles of a minimum energy
         LTIT = .FALSE.
         M = 0
         DO N = 1,NPM
            DO ND = 1,NPHI
               M = M + 1
               CURANG = ANGLE(M)
               CURWID = WIDTH(M)
               WID2   = 0.5D0*CURWID

               DIFFAN = CURANG - PREFAN(M)
 210           IF (DIFFAN.GT.180.0D0) THEN
                  DIFFAN=DIFFAN-360.0D0
                  GOTO 210
               ENDIF
 220           IF (DIFFAN.LT.-180.0D0) THEN
                  DIFFAN=DIFFAN+360.0D0
                  GOTO 220
               ENDIF

               IF (DABS(DIFFAN).GT.CURWID) THEN
C we have skipped a minimum: print out this fact,
C find the new minimum we are in and store it to PREFAN
C for future reference

C first guess: first minimum, taking phase shift into account
                  IF (DABS(PD(ICP(ND))-1.0D0).LT.1.0D-02) THEN
                     GESMIN = WID2
                  ELSE
                     GESMIN = 0.0D0
                  ENDIF

                  DIFTMP = CURANG - GESMIN
                  IF (DIFTMP.GT.180.0D0) THEN
                     DIFTMP=DIFTMP-360.0D0
                  ELSEIF (DIFTMP.LT.-180.0D0) THEN
                     DIFTMP=DIFTMP+360.0D0
                  ENDIF
C     while minimum not found
 155              IF (DABS(DIFTMP).GT.WID2) THEN
                     GESMIN = GESMIN + CURWID
                     DIFTMP = CURANG - GESMIN
                     IF (DIFTMP.GT.180.0D0) THEN
                        DIFTMP=DIFTMP-360.0D0
                     ELSEIF (DIFTMP.LT.-180.0D0) THEN
                        DIFTMP=DIFTMP+360.0D0
                     ENDIF
                     GOTO 155
                  ENDIF

                  IAT = IP(ND)
                  JAT = JP(ND)
                  KAT = KP(ND)
                  LAT = LP(ND)
C     get the residue number from the first atom
                  MM = MRES(IAT)
                  CALL SCOCN4(MAXNLE,MAXNLE,
     $                 PANM(IAT),PANM(JAT),PANM(KAT),PANM(LAT),PSTR)
                  
                  CALL SCOCN4(MAXNLE,MAXNLE,
     $                 FFTYPE(IAC(IAT)),FFTYPE(IAC(JAT)),
     $                 FFTYPE(IAC(KAT)),FFTYPE(IAC(LAT)),TSTR)

                  CALL SCOIN4(IAT,JAT,KAT,LAT,IJKSTR)
                  
                  IF (.NOT. LTIT) THEN
                     LTIT = .TRUE.
                     WRITE(6,500)'NR','RESIDUE','MOL',
     $                    ' ATOM NAMES ',
     $                    'ATOM SYMBOLS',
     $                    'ATOM NUMBERS',
     $                    'P-REF','P-NEW','DEL-P','D-P-TR'
                  ENDIF

                  WRITE(6,510)ND,MM,AANM(MM),N,
     $                 PSTR,TSTR,IJKSTR,
     $                 PREFAN(M),GESMIN,DIFFAN,CURWID

                  PREFAN(M) = GESMIN
               ENDIF
            ENDDO
         ENDDO

         IF (LTIT) THEN
            WRITE(6,*)
         ENDIF
      ENDIF

 500  FORMAT (1X,A5,A10,A5,3(6X,A12,6X),2X,4A7)
 510  FORMAT (1X,2I5,A5,I5,3(1X,A23),2X,4F7.1)
C dihmon
C     ==--------------------------------------------------------------==
      RETURN
      END
C     ==================================================================
      SUBROUTINE BONDS(NCALCD,NPM,NRP,LEVERY,
     $     NBON,IB,JB,ICB,
     $     NBTY,CB,B0,
     $     NRPT,X,F,ENER,
     $     LDOPER,RLAM,NBONG,IBG,JBG,CBA,CBB,BA0,BB0,DEDLAM,
     $     LDO34D,RMU,C4D,DEDMU)
C     ==--------------------------------------------------------------==
C     BONDS performs up to four calls of L<COBOND>, depending on
C     the LDOPER and LDO34D flags.
C     ==--------------------------------------------------------------==
C     includes
      INCLUDE 'cobond.h'
      INCLUDE 'coordsz.h'
      INCLUDE 'box.h'
C     args
      INTEGER NCALCD,NPM,NRP,NRPT
      LOGICAL LEVERY,LDOPER,LDO34D
      INTEGER NBON,IB(NBON),JB(NBON),ICB(NBON)
      INTEGER NBTY
      real*8 CB(NBTY),B0(NBTY)
      real*8 X(NDIM*NRPT),F(NDIM*NRPT)
      INTEGER NBONG
      real*8 CBA(NBONG),CBB(NBONG),BA0(NBONG),BB0(NBONG)
      INTEGER IBG(NBONG),JBG(NBONG)
      real*8 RLAM,RMU,C4D(NRPT)
C     values delivered:
      real*8 ENER,DEDLAM,DEDMU
C     local vars
      real*8 ETMP1,ETMP2,ETMP3,ETMP4
      real*8 ETMPL1,ETMPL2
      real*8 ETMPM1,ETMPM2
      real*8 EDUM,XDUM
      INTEGER IDUM,NCALOC,IB_PASS
      include '../mm_input.inc'
C     begin
      ETMP1 = 0.0D0
      ETMP2 = 0.0D0
      ETMP3 = 0.0D0
      ETMP4 = 0.0D0

      ETMPL1= 0.0D0
      ETMPL2= 0.0D0

      ETMPM1= 0.0D0
      ETMPM2= 0.0D0

      IF (LDO34D .AND. NCALCD .EQ. NDIM) THEN
         NCALOC = NDRMAX
      ELSE
         NCALOC = NCALCD
      ENDIF

      IB_PASS=IBND4
      IF(qmmm_amber) THEN
        IB_PASS=IBNDH
      ENDIF
      CALL COBOND(NCALOC,NPM,NRP,NFEF,IB_PASS,LEVERY,
     $     NBON,IB,JB,ICB,
     $     NBTY,CB,B0,
     $     NRPT,X,F,ETMP1,XDUM,EDUM,
     $     .FALSE.,XDUM,0,XDUM,XDUM,XDUM,XDUM,EDUM,
     $     .FALSE.,XDUM,XDUM,EDUM)

      IF (LDOPER .AND. NBONG .GT. 0)THEN
         CALL COBOND(NCALOC,NPM,NRP,NFEF,IB_PASS,LEVERY,
     $        NBONG,IBG,JBG,IDUM,
     $        0,XDUM,XDUM,
     $        NRPT,X,F,ETMP2,XDUM,EDUM,
     $        .TRUE.,RLAM,NBONG,CBA,CBB,BA0,BB0,ETMPL1,
     $        .FALSE.,XDUM,XDUM,EDUM)
      ENDIF

      IF (LDO34D .AND. NCALCD .EQ. NDIM) THEN
         CALL COBOND(NCALCD,NPM,NRP,NFEF,IB_PASS,LEVERY,
     $        NBON,IB,JB,ICB,
     $        NBTY,CB,B0,
     $        NRPT,X,F,ETMP3,XDUM,EDUM,
     $        .FALSE.,XDUM,0,XDUM,XDUM,XDUM,XDUM,EDUM,
     $        .TRUE.,RMU,C4D,ETMPM1)

         IF (LDOPER .AND. NBONG .GT. 0)THEN
            CALL COBOND(NCALCD,NPM,NRP,NFEF,IB_PASS,LEVERY,
     $           NBONG,IBG,JBG,IDUM,
     $           0,XDUM,XDUM,
     $           NRPT,X,F,ETMP4,XDUM,EDUM,
     $           .TRUE.,RLAM,NBONG,CBA,CBB,BA0,BB0,ETMPL2,
     $           .TRUE.,RMU,C4D,ETMPM2)
         ENDIF
      ENDIF

cmb-dbg
!      write(6,*)'CALL COBOND RESULTS:'
!      write(6,*)'ETMP1=',ETMP1
!      write(6,*)'ETMP2=',ETMP2
!      write(6,*)'ETMP3=',ETMP3
!      write(6,*)'ETMP4=',ETMP4
!      write(6,*)'ETMP1=',ETMPL1
!      write(6,*)'ETMP2=',ETMPL2
!      write(6,*)'ETMP3=',ETMPM1
!      write(6,*)'ETMP4=',ETMPM2
cmb-dbg

      ENER  = ETMP1+ETMP2+ETMP3+ETMP4
      DEDLAM= ETMPL1+ETMPL2
      DEDMU = ETMPM1+ETMPM2
C     end bonds
C     ==--------------------------------------------------------------==
      RETURN
      END
C     ==================================================================
      SUBROUTINE ANGLES(NCALCD,NPM,NRP,LEVERY,
     $     NTHEH,ITH,JTH,KTH,ICTH,
     $     NTTY,CT,T0,
     $     NRPT,X,F,ENER,
     $     LDOPER,RLAM,NTHEHG,ITHG,JTHG,KTHG,
     $     CTHA,CTHB,THA0,THB0,DEDLAM,
     $     LDO34D,RMU,C4D,DEDMU)
C     ==--------------------------------------------------------------==
COMMSUBR ANGLES
C     SUBROUTINE ANGLES(NCALCD,NPM,NRP,LEVERY,
C     $     NTHEH,ITH,JTH,KTH,ICTH,
C     $     NTTY,CT,T0,
C     $     NRPT,X,F,ENER,
C     $     LDOPER,RLAM,NTHEHG,ITHG,JTHG,KTHG,
C     $     CTHA,CTHB,THA0,THB0,DEDLAM,
C     $     LDO34D,RMU,C4D,DEDMU)
C
C     ANGLES performs up to four calls of L<ANGLE>, depending
C     on LDOPER and LDO34D.
COMMEND
C     includes
      INCLUDE 'cobond.h'
      INCLUDE 'coordsz.h'
      INCLUDE 'box.h'
C     args
      INTEGER NCALCD,NPM,NRP,NRPT
      LOGICAL LEVERY,LDOPER,LDO34D
      INTEGER NTHEH,ITH(NTHEH),JTH(NTHEH),KTH(NTHEH),ICTH(NTHEH)
      INTEGER NTTY
      real*8 CT(NTTY),T0(NTTY)

      real*8 X(NDIM*NRPT),F(NDIM*NRPT)
      INTEGER NTHEHG
      real*8 CTHA(NTHEHG),CTHB(NTHEHG),THA0(NTHEHG),THB0(NTHEHG)
      INTEGER ITHG(NTHEHG),JTHG(NTHEHG),KTHG(NTHEHG)
      real*8 RLAM,RMU,C4D(NRPT)
C     values delivered:
      real*8 ENER,DEDLAM,DEDMU
C     local vars
      real*8 ETMP1,ETMP2,ETMP3,ETMP4
      real*8 ETMPL1,ETMPL2
      real*8 ETMPM1,ETMPM2
      real*8 EDUM,XDUM
      INTEGER IDUM,NCALOC,IANGC_PASS
      include '../mm_input.inc'
C     begin
      ETMP1 = 0.0D0
      ETMP2 = 0.0D0
      ETMP3 = 0.0D0
      ETMP4 = 0.0D0

      ETMPL1= 0.0D0
      ETMPL2= 0.0D0

      ETMPM1= 0.0D0
      ETMPM2= 0.0D0

      IF (LDO34D .AND. NCALCD .EQ. NDIM) THEN
         NCALOC = NDRMAX
      ELSE
         NCALOC = NCALCD
      ENDIF

      IANGC_PASS=IANGC
      IF(qmmm_amber) THEN 
        IANGC_PASS=IANGH
      ENDIF
      CALL ANGLE(NCALOC,NPM,NRP,NFEF,IANGC_PASS,LEVERY,
     $     NTHEH,ITH,JTH,KTH,ICTH,
     $     NTTY,CT,T0,
     $     NRPT,X,F,ETMP1,XDUM,EDUM,
     $     .FALSE.,XDUM,0,XDUM,XDUM,XDUM,XDUM,EDUM,
     $     .FALSE.,XDUM,XDUM,EDUM)

      IF (LDOPER .AND. NTHEHG .GT. 0) THEN
         CALL ANGLE(NCALOC,NPM,NRP,NFEF,IANGC_PASS,LEVERY,
     $        NTHEHG,ITHG,JTHG,KTHG,IDUM,
     $        0,XDUM,XDUM,
     $        NRPT,X,F,ETMP2,XDUM,EDUM,
     $        .TRUE.,RLAM,NTHEHG,CTHA,CTHB,THA0,THB0,ETMPL1,
     $        .FALSE.,XDUM,XDUM,EDUM)
      ENDIF

      IF (LDO34D .AND. NCALCD .EQ. NDIM) THEN
         CALL ANGLE(NCALCD,NPM,NRP,NFEF,IANGC_PASS,LEVERY,
     $        NTHEH,ITH,JTH,KTH,ICTH,
     $        NTTY,CT,T0,
     $        NRPT,X,F,ETMP3,XDUM,EDUM,
     $        .FALSE.,XDUM,0,XDUM,XDUM,XDUM,XDUM,EDUM,
     $        .TRUE.,RMU,C4D,ETMPM1)

         IF (LDOPER .AND. NTHEHG .GT. 0) THEN
            CALL ANGLE(NCALCD,NPM,NRP,NFEF,IANGC_PASS,LEVERY,
     $           NTHEHG,ITHG,JTHG,KTHG,IDUM,
     $           0,XDUM,XDUM,
     $           NRPT,X,F,ETMP4,XDUM,EDUM,
     $           .TRUE.,RLAM,NTHEHG,CTHA,CTHB,THA0,THB0,ETMPL2,
     $           .TRUE.,RMU,C4D,ETMPM2)
         ENDIF
      ENDIF

      ENER  = ETMP1+ETMP2+ETMP3+ETMP4
      DEDLAM= ETMPL1+ETMPL2
      DEDMU = ETMPM1+ETMPM2
C     end angles
C     ==--------------------------------------------------------------==
      RETURN
      END
C     ==================================================================
      SUBROUTINE DIHDLS(NCALCD,NPM,NRP,LEVERY,
     $     NPHIH,IPH,JPH,KPH,LPH,ICPH,
     $     NPTY,CP,PD,NP,
     $     NRPT,X,F,ENER,
     $     LDOPER,RLAM,NPHIHG,IPHG,JPHG,KPHG,LPHG,
     $     CPHA,CPHB,PDHA,PDHB,NPHA,NPHB,DEDLAM,
     $     LDO34D,RMU,C4D,DEDMU)
C     ==--------------------------------------------------------------==
COMMSUBR DIHDLS
C     SUBROUTINE DIHDLS(NCALCD,NPM,NRP,LEVERY,
C     $     NPHIH,IPH,JPH,KPH,LPH,ICPH,
C     $     NPTY,CP,PD,NP,
C     $     NRPT,X,F,ENER,
C     $     LDOPER,RLAM,NPHIHG,IPHG,JPHG,KPHG,LPHG,
C     $     CPHA,CPHB,PDHA,PDHB,NPHA,NPHB,DEDLAM,
C     $     LDO34D,RMU,C4D,DEDMU)
C
C     DIHDLS performs up to four calls od <DIHANG>, depending
C     on LDOPER and LDO34D.
C     ==--------------------------------------------------------------==
C     includes
      INCLUDE 'cobond.h'
      INCLUDE 'coordsz.h'
      INCLUDE 'box.h'
C     args
      INTEGER NCALCD,NPM,NRP,NRPT
      LOGICAL LEVERY,LDOPER,LDO34D

      INTEGER NPHIH,IPH(NPHIH),JPH(NPHIH)
      INTEGER KPH(NPHIH),LPH(NPHIH),ICPH(NPHIH)
      INTEGER NPTY,NP(NPTY)
      real*8 CP(NPTY),PD(NPTY)

      real*8 X(NDIM*NRPT),F(NDIM*NRPT)

      INTEGER NPHIHG
      real*8 CPHA(NPHIHG),CPHB(NPHIHG),PDHA(NPHIHG),PDHB(NPHIHG)
      INTEGER NPHA(NPHIHG),NPHB(NPHIHG)
      INTEGER IPHG(NPHIHG),JPHG(NPHIHG),KPHG(NPHIHG),LPHG(NPHIHG)
      real*8 RLAM,RMU,C4D(NRPT)
C     values delivered:
      real*8 ENER,DEDLAM,DEDMU
C     local vars
      real*8 ETMP1,ETMP2,ETMP3,ETMP4
      real*8 ETMPL1,ETMPL2
      real*8 ETMPM1,ETMPM2
      real*8 EDUM,XDUM
      INTEGER IDUM,NCALOC
C     begin
      ETMP1 = 0.0D0
      ETMP2 = 0.0D0
      ETMP3 = 0.0D0
      ETMP4 = 0.0D0

      ETMPL1= 0.0D0
      ETMPL2= 0.0D0

      ETMPM1= 0.0D0
      ETMPM2= 0.0D0

C     if mu perturbation is on and dihedrals are in 4D
      IF (LDO34D .AND. NCALCD .EQ. NDIM) THEN
         NCALOC = NDRMAX
      ELSE
         NCALOC = NCALCD
      ENDIF

      CALL DIHANG(NCALOC,NPM,NRP,NFEF,IDICOS,LEVERY,
     $     NPHIH,IPH,JPH,KPH,LPH,ICPH,
     $     NPTY,CP,PD,NP,
     $     NRPT,X,F,ETMP1,XDUM,EDUM,
     $     .FALSE.,XDUM,0,XDUM,XDUM,XDUM,XDUM,IDUM,IDUM,EDUM,
     $     .FALSE.,XDUM,XDUM,EDUM)

      IF (LDOPER .AND. NPHIHG .GT. 0)THEN
         CALL DIHANG(NCALOC,NPM,NRP,NFEF,IDICOS,LEVERY,
     $        NPHIHG,IPHG,JPHG,KPHG,LPHG,IDUM,
     $        0,XDUM,XDUM,IDUM,
     $        NRPT,X,F,ETMP2,XDUM,EDUM,
     $        .TRUE.,RLAM,NPHIHG,CPHA,CPHB,PDHA,PDHB,
     $        NPHA,NPHB,ETMPL1,
     $        .FALSE.,XDUM,XDUM,EDUM)
      ENDIF

      IF (LDO34D .AND. NCALCD .EQ. NDIM) THEN
         CALL DIHANG(NCALCD,NPM,NRP,NFEF,IDICOS,LEVERY,
     $        NPHIH,IPH,JPH,KPH,LPH,ICPH,
     $        NPTY,CP,PD,NP,
     $        NRPT,X,F,ETMP3,XDUM,EDUM,
     $        .FALSE.,XDUM,0,XDUM,XDUM,XDUM,XDUM,IDUM,IDUM,EDUM,
     $        .TRUE.,RMU,C4D,ETMPM1)
         
         IF (LDOPER .AND. NPHIHG .GT. 0) THEN
            CALL DIHANG(NCALCD,NPM,NRP,NFEF,IDICOS,LEVERY,
     $           NPHIHG,IPHG,JPHG,KPHG,LPHG,IDUM,
     $           0,XDUM,XDUM,IDUM,
     $           NRPT,X,F,ETMP2,XDUM,EDUM,
     $           .TRUE.,RLAM,NPHIHG,CPHA,CPHB,PDHA,PDHB,
     $           NPHA,NPHB,ETMPL2,
     $           .TRUE.,RMU,C4D,ETMPM2)
         ENDIF
      ENDIF

      ENER  = ETMP1+ETMP2+ETMP3+ETMP4
      DEDLAM= ETMPL1+ETMPL2
      DEDMU = ETMPM1+ETMPM2
C     end dihdls
C     ==--------------------------------------------------------------==
      RETURN
      END
C     ==================================================================
