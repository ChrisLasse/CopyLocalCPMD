Index: doc/manual/manual.tex
===================================================================
--- doc/manual/manual.tex	(revision 4634)
+++ doc/manual/manual.tex	(revision 4635)
@@ -898,9 +898,9 @@
 CRD\_INI.grm \> Positions of all atoms of first step in Gromos format (QM/MM only).\\
 CRD\_FIN.grm \> Positions of all atoms of last step in Gromos format (QM/MM only).\\
 MM\_TOPOLOGY \> New Gromos format topology file (QM/MM only).\\
-ESP          \> Containes the ESP charges of the QM atoms (QM/MM only).\\
+ESP          \> Contains the ESP charges of the QM atoms (QM/MM only).\\
 EL\_ENERGY   \> Contains the electrostatic interaction energy (QM/MM only).\\
-MULTIPOLE    \> Contains the dipole- and the quadrupole-momenent of the quantum system.\\
+MULTIPOLE    \> Contains the dipole- and the quadrupole-moment of the quantum system.\\
 MM\_CELL\_TRANS \> Contains the trajectory of the offset of the QM cell (QM/MM only).\\
 \\
 OCCMAT       \> The "trajectory" of the Occupation Matrix (DFT+U only)\\
@@ -1791,12 +1791,12 @@
 
 \keyword{BICANONICAL ENSEMBLE}{\{CHEMICALPOTENTIAL,\,XWEIGHT\} }{[INFO]}{}{\&CPMD}
     %
-  \desc{Use the bicanonical ensemble AIMD for simualtion of open
+  \desc{Use the bicanonical ensemble AIMD for simulation of open
     systems~\cite{Frenzel2017}. 
     %
     \\
     %
-    Note, requesting this runtype cpmd must be excecuted on more then one MPI
+    Note, requesting this runtype cpmd must be executed on more then one MPI
     thread.
     %
     \\
@@ -1872,13 +1872,13 @@
     system 1.
     %
     Thus the INPUT for system 2 is created from 1 by removing that species and
-    then apply optional changes, \textit{e.g.\@} modifiy the number of
+    then apply optional changes, \textit{e.g.\@} modify the number of
     electrons in that system via the CHARGE keyword. 
     %
     Note, positions and velocities of the atomic nuclei must be the same in
     both systems.
     %
-    A restart from preoptimized electronic wavefunctions of the inividual
+    A restart from preoptimized electronic wavefunctions of the individual
     canonical systems is recommended (see Sec.~\ref{FILES} and CPMD regtests 
     BICAN/mdX0\_50, BICAN/c-cnf1, BICAN/c-cnf2).   
     %
@@ -2063,7 +2063,7 @@
 
 \keyword{CG-FACTOR}{}{}{}{\&RESP}
   \desc{The analytic length calculation of the conjugate-gradient step
-  lengthes yields in general a result that is slightly too large. This
+  lengths yields in general a result that is slightly too large. This
   factor is used to correct for that deficiency. No accuracy impact,
   pure convergence speed tuning.\\ \textbf{Default} is
   \defaultvalue{0.8}.}
@@ -2801,7 +2801,7 @@
 \spekeyword{EXT\_PULSE}{}{}{}{\&PTDDFT}{EXT-PULSE}
   \desc{A Dirac type pulse is applied to the KS orbitals before propagation.
 This keyword is used with the principal keyword \refkeyword{PROPAGATION SPECTRA}. The intensity
-of the perturbing field is readi from the next line.}
+of the perturbing field is read from the next line.}
 
 \spekeyword{EXT\_POTENTIAL}{}{}{}{\&PTDDFT}{EXT-POTENTIAL}
   \desc{An external potential is applied to the KS orbitals before propagation.
@@ -3128,6 +3128,13 @@
         %
         This is the default if \refkeyword{INITIALIZATION} is active.}
 
+\keyword{GLE\_LAMBDA}{}{}{}{\&PIMD}
+  \desc{Set the scaling factor $\lambda $ of the generalized Langevin thermostat 
+        read from the next line for removing the resonances between the vibrations 
+        of the system and the harmonic potential representing the quantum kinetic 
+        energy term in the description of the path integral. 
+        The default value is 0.5 as suggested in Ref.~\cite{Rossi2014}.}
+
 \keyword{GRADIENT CORRECTION}{}{}{[functionals]}{\&DFT}
   \desc{Individual components of gradient corrected functionals can be
     selected. Rarely needed anymore, use the \refkeyword{FUNCTIONAL}
@@ -3240,7 +3247,7 @@
     \&DFT section with the \refspekeyword{MTS\_HIGH\_FUNC}{MTS HIGH FUNC} keyword.
     (ii) The forces are calculated by an external program which called via a script which should be named
     \texttt{EXT\_HIGH\_FORCES}. When the forces are needed, CPMD will write a file \texttt{geometry.xyz} containing
-    the current geometry in xyz format (carthesian coordinates in Aangstroms). Then the script will 
+    the current geometry in xyz format (cartesian coordinates in Angstroms). Then the script will 
     be called and CPMD will wait until a file \texttt{forces.xyz} becomes available with the new forces
     in xyz format (atomic units are expected). See the \texttt{get\_external\_forces} routine in the
     \texttt{interface\_utils.mod.F90} file.
@@ -3552,7 +3559,7 @@
    DETAILS  = argument for verbosity. prints a lot of stuff
    }
 
-\keyword{LANGEVIN}{\{WHITE, CPMD, OPTIMAL, SMART, CUSTOM\}}{[MOVECM]}{[W0, NS]}{\&CPMD}
+\keyword{LANGEVIN}{\{WHITE, CPMD, OPTIMAL, SMART, CUSTOM, CENTROIDOFF\}}{[MOVECM]}{[W0, NS]}{\&CPMD}
   \desc{Use a (generalized) Langevin equation to thermostat the simulation\cite{Ceriotti10}. 
    By default, the component of the noise parallel to the center of mass velocity is 
      removed at each step of the thermostat. Removal can be disabled by the option {\sl MOVECM}.
@@ -3600,7 +3607,16 @@
                   next line. Will be about 50\%{} more efficient than {\sl OPTIMAL} for slow
                   modes, but less efficient for fast vibrations. Use only with Born-Oppenheimer
                   dynamics.
-                      \end{minipage}                      
+                      \end{minipage}
+
+   {\sl CENTROIDOFF:} \hfill\begin{minipage}[t]{10cm}
+                 For centroid and ring-polymer dynamics the generalized Langevin thermostat
+                 for the centroids can be switched off by using the optional keyword CENTROIDOFF 
+                 otherwise the thermostat with the frequency read from the next line is attached 
+                 to the centroids. For each non-centroid mode the frequency of the thermostat 
+                 is automatically determined depending on the frequency of its associated harmonic 
+                 potential representing the quantum kinetic energy term.  
+                      \end{minipage}
   }
 
 \keyword{LBFGS}{}{[NREM, NTRUST, NRESTT, TRUSTR]}{}{\&CPMD}
@@ -3854,7 +3870,7 @@
       section {\&PTDDFT} has to be specified. You need to start the dynamics with well converged
       KS orbitals from the RESTART file (before starting the EH dynamics do an optimization of the
       wavefunction with a convergence of {1.D-8} or {1.D-9}, if possible. An additional file
-      called "wavefunctions" is produced, which containes the complex KS orbitals needed for
+      called "wavefunctions" is produced, which contains the complex KS orbitals needed for
       the restart of the EH dynamics (see restart options in {\&PTDDFT}). Typical (minimal) input
       \&CPMD and \&PTDDFT sections to be used with EH dynmiacs\\
       \&CPMD \\
@@ -4035,7 +4051,7 @@
       {\bf If the keyword is used \underline{all} parameters have to be
       specified.}}
 
-\keyword{NOSE}{\{IONS, ELECTRONS, CELL\}}{[ULTRA,MASSIVE,CAFES,LOCAL]}{}{[T0]}{\&CPMD}
+\keyword{NOSE}{\{IONS, ELECTRONS, CELL\}}{[ULTRA,MASSIVE,CAFES,LOCAL,CENTROIDOFF]}{[T0]}{\&CPMD}
   \desc{{\bf Nos\'e-Hoover chains}~\cite{Nose84,Hoover85} for the {\bf
       ions}, {\bf electrons}, or {\bf cell parameters} are used.\\
       The {\bf target temperature} in Kelvin and
@@ -4101,6 +4117,15 @@
       LOCAL thermostat). By default it is same as the target temperature of the thermostat. 
       Note: This is not implemented for the CAFES thermostat.}
 
+      The keyword {\bf CENTROIDOFF} is intended to be used in connection with 
+      the centroid and ring-polymer dynamics. In this type of path integral MD,
+      you can request not to attach the Nos{\' e}-Hoover chains for ions to the centroids 
+      by explicit use of the keyword CENTROIDOFF, otherwise the thermostat with the 
+      frequency read from the next line is attached to the centroids.
+      For each non-centroid mode the frequency with the Nos{\' e}-Hoover chains is 
+      automatically determined depending on the frequency of its associated harmonic potential 
+      representing the {\it quantum} kinetic energy term.  
+
 \keyword{NPREVIOUS}{}{}{}{\&PATH}
   \desc{String index to restart from. Note that this is just for numbering files, the initial path in collective variables for the search is always {\em string.inp}.}
 
@@ -4635,6 +4660,19 @@
         to restrict the calculation to only one state. The number of the
         state is read from the next line.}
 
+\keyword{RING-POLYMER DYNAMICS}{}{}{}{\&PIMD}
+  \desc{Perform ring-polymer molecular dynamics (RPMD)~\cite{Craig2004}.  
+        In the present implementation the fictitious mass of the  nuclei for 
+        all the replicas is set to the real physical mass divided by the number 
+        of replicas (P) in the primitive representation and the physical mass 
+        in the normal mode representation for compatibility with the formulation 
+        of the conventional path integral. According to our choice of the fictitious 
+        masses, the target temperature you should set is not TP in the original
+        formulation of Ref.~\cite{Craig2004}  but just T as in the standard path 
+        integral and centroid MD. Note that RPMD in the staging mode representation 
+        is not supported and the generalized Langevin thermostat is available in the 
+        normal mode representation only.}
+
 \keyword{QMMM}{}{[QMMMEASY]}{}{\&CPMD}
 \desc{Activate the hybrid QM/MM code. This keyword requires
       further input in the section \&QMMM \dots \&END.
@@ -4869,7 +4907,7 @@
          1. restart from the orbital files WAVEFUNCTION.n, where $n$ is the index 
          of the KS orbital and runs from $1$ to the number of states (This states 
          a prepare in a previous run using the KOHN-SHAM ENERGIES
-         principal keyward), 2; restart from the orbitals stored in RESTART (obtained
+         principal keyword), 2; restart from the orbitals stored in RESTART (obtained
          from a optimization run with tight convergence (at least 1.D-7)).}
 
 \keyword{REVERSE VELOCITIES}{}{}{}{\&CPMD}
@@ -5669,7 +5707,7 @@
       The first line contains first the total number of specified atomic velocities
       followed \textbf{on the same line} by the list of atomic numbers
       for which the velocities will be read.
-      On each of the follwoing lines the x, y and z coordinates of the
+      On each of the following lines the x, y and z coordinates of the
       velocities of an atom have to be specified. These values will
       ignored in case of starting with \refkeyword{RESTART} VELOCITIES..
 
@@ -6023,7 +6061,7 @@
            This is ignored unless you are running a QM/MM
            calculation with the Gromos interface code.
            The definition of what is a solute is taken from the
-           respecitve GROMOS topology file.
+           respective GROMOS topology file.
 
         \item[FIX SEQUENCE]\hfill \\
           {\bf All coordinates} of a series of atoms are kept fixed.\\
@@ -6548,7 +6586,7 @@
 from which the first line gives the number of the total atoms. An .xyz
 file can also be recorded directly during the simulation Using the
 \refkeyword{TRAJECTORY} keyword with the option {\bf XYZ}.\\
-Please note, that CPMD does not apply the minium image convention
+Please note, that CPMD does not apply the minimum image convention
 to these trajectory files, i.e. atoms are \textbf{not} replaced by their
 images if they leave the supercell.
 
@@ -6575,7 +6613,7 @@
 \subsection{The MOVIE format}
 
 Besides the TRAJECTORY file CPMD also produces a specially
-formated trajectory in the MOVIE file. This file contains the position
+formatted trajectory in the MOVIE file. This file contains the position
 of all atoms of the system in Angstrom units at a rather low
 precision ($10^{-4}$). The sampling of the positions can be done
 independently from the trajectory file. The sets of coordinates are
@@ -11411,7 +11449,7 @@
 
 \bibitem{Frenzel2017}
     J.~Frenzel, B.~Meyer, D.~Marx, 
-    \em{Bicanonical Ab Initio Molecular Dynamics for Open Systems}
+    {\em Bicanonical Ab Initio Molecular Dynamics for Open Systems}
     J. Chem. Theory Comput., Just Accepted Manuscript 
     (2017), 
     DOI: 10.1021/acs.jctc.7b00263 .
@@ -11551,6 +11589,10 @@
     P.~Cs\'asz\'ar and P.~Pulay,
     J.~Mol.~Struct. {\bf 114} 31 (1984).
 
+\bibitem{Rossi2014}
+    M.~Rossi, M.~Ceriotti, and D.~E.~Manolopoulos, 
+    J.~Chem.~Phys. {\bf 140}, 234116 (2014).
+
 \bibitem{Perdew92}
     J.~P.~Perdew, J.~A.~Chevary, S.~H.~Vosko, K.~A.~Jackson,
     M.~R.~Pederson, D.~J.~Singh, and C.~Fiolhais, 
@@ -11679,6 +11721,10 @@
     A.~J. Turner, V.~Moliner and I.~H. Williams,
     Phys.~Chem.~Chem.~Phys. {\bf 1}, 1323 (1999).
 
+\bibitem{Craig2004}
+    R. Craig and D.~E.~Manolopoulos, 
+    J.~Chem.~Phys. {\bf 121}, 3368 (2004).
+
 \bibitem{gromos96}
     W.~F.~van~Gunsteren, S.~R.~Billeter, A.~A.~Eising, P.~H.~H\"unenberger,
     P.~Kr\"uger, A.~E.~Mark, W.~R.~P.~Scott, I.~G.~Tironi,
Index: src/detdof_utils.mod.F90
===================================================================
--- src/detdof_utils.mod.F90	(revision 4634)
+++ src/detdof_utils.mod.F90	(revision 4635)
@@ -3,6 +3,7 @@
   USE cnstfc_utils,                    ONLY: cnstfc,&
                                              restfc
   USE cnstpr_utils,                    ONLY: cnstpr
+  USE comvelmod,                       ONLY: comvl
   USE cotr,                            ONLY: &
        anorm, askel, bsigma, cnsval, cotc0, cotr007, csigm, dsigma, dtm, &
        duat, fc, fcstr, fv, lskcor, lskptr, mm_askel, ntcnst, ntrest, patot, &
@@ -11,6 +12,7 @@
   USE dum2_utils,                      ONLY: dum2,&
                                              dumpr
   USE error_handling,                  ONLY: stopgm
+  USE glemod,                          ONLY: tglepc
   USE ions,                            ONLY: ions0,&
                                              ions1
   USE isos,                            ONLY: isos1
@@ -22,7 +24,8 @@
   USE nose,                            ONLY: glib,&
                                              loct,&
                                              nosl,&
-                                             tcafes
+                                             tcafes,&
+                                             tnosepc
   USE parac,                           ONLY: paral
   USE pimd,                            ONLY: pimd1
   USE rmas,                            ONLY: rmass
@@ -664,8 +667,8 @@
     ! ..      (staging) bead, whereas all other beads have always 3*NAT
     ! ..      degrees of freedom each in the path integral case
     ! ..      (the latter case is handled via GLIB_S=3._real_8*NAT)
-    ! ..      For Centroid cntl%md: TCENTRO=.TRUE.
-    ! ..                       first bead is NOT thermostatted in any case,
+    ! ..      For CMD: TCENTRO=.TRUE. or RPMD: TRINGP=.TRUE.
+    ! ..                       first bead should NOT be thermostatted 
     ! ..                       which means that GLIB has to be calculated
     ! ..                       as for a classical simulation
     ! ..      MCNSTR is the number of internal constraints
@@ -683,7 +686,9 @@
           ENDIF
        ENDDO
     ENDDO
-    IF (.NOT.pimd1%tcentro) THEN
+    IF (.NOT.((pimd1%tcentro.OR.pimd1%tringp)&
+        .AND.(pimd1%tstage.OR.pimd1%tpinm)&
+        .AND.(.NOT.tnosepc.OR..NOT.tglepc.OR.comvl%tsubcom))) THEN
        glib=REAL(cotc0%nodim,kind=real_8)
     ELSE
        IF (cotc0%nodim.NE.3*ions1%nat) THEN
Index: src/md_driver.mod.F90
===================================================================
--- src/md_driver.mod.F90	(revision 4634)
+++ src/md_driver.mod.F90	(revision 4635)
@@ -149,6 +149,7 @@
   USE rinitwf_utils,                   ONLY: give_scr_rinitwf
   USE rinvel_utils,                    ONLY: rinvel,&
                                              rvscal
+  USE rmas,                            ONLY: rmass
   USE rnlsm_utils,                     ONLY: give_scr_rnlsm
   USE ropt,                            ONLY: infi,&
                                              iteropt,&
@@ -613,6 +614,8 @@
           if(ierr/=0) call stopgm(proceduren,'allocation problem: cold_high',&
                __LINE__,__FILE__)
           call zeroing(cold_high)
+          numcold_high=0 
+          nnow_high=0
           rmem=rmem*2._real_8
        endif
 
@@ -938,7 +941,7 @@
     ENDIF
 
     ! INITIALIZE GLE THERMO
-    CALL gle_init
+    CALL gle_init(tau0,velp,rmass%pma)
 
     CALL write_irec(irec)
     ! ==--------------------------------------------------------------==
@@ -1012,7 +1015,7 @@
           ! UPDATE NOSE THERMOSTATS
           CALL noseup(velp,c2,nstate,ipwalk)
           ! FIRST HALF OF GLE EVOLUTION
-          CALL gle_step
+          CALL gle_step(tau0,velp,rmass%pma)
        endif 
        ! SUBTRACT CENTER OF MASS VELOCITY
        IF (paral%io_parent.AND.comvl%subcom) CALL comvel(velp,vcmio,.TRUE.)
@@ -1239,7 +1242,7 @@
        ! thermostats only if 1) standard dynamics 2) larger MTS step
        if ( .not.cntl%use_mts .or. mts_large_step ) then
           ! SECOND HALF OF GLE EVOLUTION
-          CALL gle_step
+          CALL gle_step(tau0,velp,rmass%pma)
 
           ! UPDATE NOSE THERMOSTATS
           CALL noseup(velp,c2,nstate,ipwalk)
@@ -1277,7 +1280,7 @@
             rhoe,psi,nstate,nkpt%nkpnt,iteropt%nfi,infi)
        ! PRINTOUT the evolution of the accumulators every time step
        IF (paral%io_parent) THEN
-          econs=ekinp+ener_com%etot+enose+enosp+ener_com%ecnstr+ekincv+vharm+glepar%egle
+          econs=ekinp+ener_com%etot+enose+enosp+ener_com%ecnstr+ekincv+vharm+glepar%egle 
           IF (cntl%cdft)THEN
              econs=econs+cdftcom%cdft_v(1)*(cdftcom%cdft_nc+cdftcom%vgrad(1))
           ENDIF
Index: src/wr_temps_utils.mod.F90
===================================================================
--- src/wr_temps_utils.mod.F90	(revision 4634)
+++ src/wr_temps_utils.mod.F90	(revision 4635)
@@ -13,7 +13,8 @@
                                              qnosee,&
                                              qnospm,&
                                              qnospc,&
-                                             etap1dot
+                                             etap1dot,&
+                                             nosl
   USE parac,                           ONLY: paral
   USE pimd,                            ONLY: grandparent,&
                                              maxnp,&
@@ -57,14 +58,16 @@
     IF (paral%parent) THEN
        DO ip=np_low,np_high
           ipp=MIN(2,ip)
-          IF (.NOT.(pimd1%tcentro.AND.ip==1)) THEN
-             DO k=1,ntherm(ipp)
-                etptemp(ip)=etptemp(ip)+factem*qnospm(k,1,ip)*&
-                     etapmdot(k,1,ip)**2
-             ENDDO
-             etptemp(ip)=etptemp(ip)/REAL(ntherm(ipp),kind=real_8)
-          ELSE
-             etptemp(ip)=etptemp(ip)+factem*qnospc(1,ip)*etap1dot(1,ip)**2
+          IF (cntl%tnosep) THEN
+             IF (nosl%tmnose.AND..NOT.(pimd1%tcentro.AND.ip==1)) THEN
+                DO k=1,ntherm(ipp)
+                   etptemp(ip)=etptemp(ip)+factem*qnospm(k,1,ip)*&
+                        etapmdot(k,1,ip)**2
+                ENDDO
+                etptemp(ip)=etptemp(ip)/REAL(ntherm(ipp),kind=real_8)
+             ELSE
+                etptemp(ip)=etptemp(ip)+factem*qnospc(1,ip)*etap1dot(1,ip)**2
+             ENDIF
           ENDIF
           IF (cntl%tnosee)&
              etetemp(ip)=etetemp(ip)+0.5_real_8*qnosee(1)*etadot(1,ip)**2
@@ -107,7 +110,7 @@
        ! ETE1  temperature of electronic thermostat of IP=1 (centroid)
        ! ETEM  temperature of electronic thermostat averaged over IP=2,NP
        IF (paral%io_parent)&
-            WRITE(4,'(I7,F7.1,F7.1,F10.5,F10.5,F7.1,F7.1,F10.5,F10.5)')&
+            WRITE(4,'(I9,F7.1,F7.1,F10.5,F10.5,F7.1,F7.1,F10.5,F10.5)')&
             nfi,tp1,tpm,et1,etm,etp1,etpm,ete1,etem
        IF (paral%io_parent)&
             CALL fileclose(4)
Index: src/pi_npt_bomd_utils.mod.F90
===================================================================
--- src/pi_npt_bomd_utils.mod.F90	(revision 4634)
+++ src/pi_npt_bomd_utils.mod.F90	(revision 4635)
@@ -79,6 +79,7 @@
   USE nosepa_utils,                    ONLY: nosepa
   USE noseup_utils,                    ONLY: noseup
   USE nospinit_utils,                  ONLY: nospinit
+  USE ortho_utils,                     ONLY: ortho
   USE parac,                           ONLY: parai,&
                                              paral
   USE phfac_utils,                     ONLY: phfac
@@ -90,6 +91,7 @@
   USE pinmtrans_utils,                 ONLY: pinmtrans
   USE pi_stress_utils,                 ONLY: pi_stress_vir,&
                                              wr_pi_stress
+  USE pi_wf_utils,                     ONLY: initrep
   USE poin,                            ONLY: rhoo
   USE posupi_utils,                    ONLY: posupi,&
                                              posupih,&
@@ -118,6 +120,7 @@
                                              iteropt,&
                                              ropt_mod
   USE rotvel_utils,                    ONLY: rotvel
+  USE rrane_utils,                     ONLY: rrane
   USE rscvp_utils,                     ONLY: rscvp
   USE rv30_utils,                      ONLY: zhrwf
   USE setirec_utils,                   ONLY: read_irec,&
@@ -319,20 +322,25 @@
        ALLOCATE(cold(nkpt%ngwk,crge%n,nkpt%nkpnt,lenext/(crge%n*nkpt%ngwk*nkpt%nkpnt)),STAT=ierr)
        IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
             __LINE__,__FILE__)
-       IF (paral%io_parent)&
-            WRITE(6,'(A,T51,F8.3,A)') ' PI_NPT_BOMD| '&
-            // 'EXTRAPOL WAVEFUNCTION HISTORY TAKES ',rmem,' MBYTES'
+       call zeroing(cold)
        IF (np_local>1) THEN
           ALLOCATE(coldall(nkpt%ngwk,crge%n,nkpt%nkpnt,cnti%mextra,np_local),STAT=ierr)
           IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
                __LINE__,__FILE__)
+          call zeroing(coldall)
           ALLOCATE(nnowall(np_local),STAT=ierr)
           IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
                __LINE__,__FILE__)
+          call zeroing(nnowall)
           ALLOCATE(numcoldall(np_local),STAT=ierr)
           IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
                __LINE__,__FILE__)
+          call zeroing(numcoldall)
+          rmem=rmem+rmem*REAL(np_local,kind=real_8)
        ENDIF
+       IF (paral%io_parent)&
+            WRITE(6,'(A,T51,F8.3,A)') ' PI_NPT_BOMD| '&
+            // 'EXTRAPOL WAVEFUNCTION HISTORY TAKES ',rmem,' MBYTES'
     ENDIF
     ! ==--------------------------------------------------------------==
     ! SCR ALLOCATION AND PARTITION (SCRATCH ARRAY).
@@ -371,65 +379,58 @@
        nosl%tmnose=pitmnose(MIN(ipcurr,2))
        cntl%tnosec=pitnosec(MIN(ipcurr,2))
        CALL read_irec(irec(:,ipcurr))
-       ! ..Construct filenames
-       cflbod='RESTART_'
-       IF (paral%io_parent)&
-            WRITE(cipnum,'(I4)') ipcurr
-       CALL xstring(cflbod,n1,n2)
-       CALL xstring(cipnum,i1,i2)
-       filbod=cflbod(n1:n2)//cipnum(i1:i2)//'.1'
-       IF (restart1%rlate) THEN
-          filn=filbod
-       ELSE
-          filn=cflbod(n1:n2)//cipnum(i1:i2)
-       ENDIF
-       ! ..Read restart file
-       ipx=ipcurr-np_low+1
-       CALL zhrwf(1,irec(:,ipcurr),c0(:,:,ipx:ipx),c2,crge%n,eigv(:,ipx),&
-            pitaup(:,:,:,ipcurr),&
-            pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),iteropt%nfi)
-       CALL dcopy(nacc,acc,1,accus(1,ipcurr),1)
-       IF (restart1%rgeo) THEN
-          IF (paral%io_parent) CALL geofile(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),'READ')
-          CALL mp_bcast(pitaup(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(pivelp(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(metr_com%ht,SIZE(metr_com%ht),parai%io_source,parai%cp_grp)
-          CALL mp_bcast(metr_com%htvel,SIZE(metr_com%htvel),parai%io_source,parai%cp_grp)
-          restart1%rcell=.TRUE.; restart1%rvel=.TRUE.
-       ENDIF
-       IF (irec(irec_rho,ipcurr).NE.0) THEN
-          CALL dcopy(nnx,rhoo,1,rall(1,ipx),1)
-       ENDIF
-       ! ..Randomization of the atomic coordinates
-       IF (cntl%tranp.AND.paral%parent) CALL ranp(pitaup(:,:,:,ipcurr))
-       ! ..Read WF centers & spread from restart file
-       IF (vdwl%vdwd) THEN
-          IF (paral%io_parent) THEN
-             nwfc=crge%n
-             vdwwfl%trwannc=trwanncx(ipx)
-             CALL rwannier(nwfc,tauref(:,:,:,ipx),rwann(:,:,ipx),swann(:,ipx),&
-                  vdwwfl%trwannc)
-             IF (.NOT.vdwwfl%trwannc) THEN
-                CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),&
-                     1,tauref(1,1,1,ipx),1)
-             ENDIF
+       IF (restart1%restart) THEN
+          ! ..Construct filenames
+          cflbod='RESTART_'
+          IF (paral%io_parent)&
+               WRITE(cipnum,'(I4)') ipcurr
+          CALL xstring(cflbod,n1,n2)
+          CALL xstring(cipnum,i1,i2)
+          filbod=cflbod(n1:n2)//cipnum(i1:i2)//'.1'
+          IF (restart1%rlate) THEN
+             filn=filbod
+          ELSE
+             filn=cflbod(n1:n2)//cipnum(i1:i2)
           ENDIF
-          CALL mp_bcast(tauref(:,:,:,ipx),3*maxsys%nax*maxsys%nsx,&
-               parai%io_source,parai%cp_grp)
-          CALL mp_bcast(rwann(:,:,ipx),3*nwfcx*nfragx,parai%io_source,&
-               parai%cp_grp)
-          CALL mp_bcast(swann(:,ipx),nwfcx*nfragx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(vdwwfl%trwannc,parai%io_source,parai%cp_grp)
-          trwanncx(ipx)=vdwwfl%trwannc
+          ! ..Read restart file
+          ipx=ipcurr-np_low+1
+          CALL zhrwf(1,irec(:,ipcurr),c0(:,:,ipx:ipx),c2,crge%n,eigv(:,ipx),&
+               pitaup(:,:,:,ipcurr),&
+               pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),iteropt%nfi)
+          CALL dcopy(nacc,acc,1,accus(1,ipcurr),1)
+          IF (restart1%rgeo) THEN
+             IF (paral%io_parent) CALL geofile(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),'READ')
+             CALL mp_bcast(pitaup(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
+             CALL mp_bcast(pivelp(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
+             CALL mp_bcast(metr_com%ht,SIZE(metr_com%ht),parai%io_source,parai%cp_grp)
+             CALL mp_bcast(metr_com%htvel,SIZE(metr_com%htvel),parai%io_source,parai%cp_grp)
+             restart1%rcell=.TRUE.; restart1%rvel=.TRUE.
+          ENDIF
+          IF (irec(irec_rho,ipcurr).NE.0) THEN
+             CALL dcopy(nnx,rhoo,1,rall(1,ipx),1)
+          ENDIF
+          ! ..Randomization of the atomic coordinates
+          IF (cntl%tranp.AND.paral%parent) CALL ranp(pitaup(:,:,:,ipcurr))
+          ! ..Initialization of wavefunction
+          IF (irec(irec_wf,ipcurr).EQ.0) THEN
+             CALL rinitwf(c0(:,:,ipx:ipx),c2,sc0,crge%n,pitaup(:,:,:,ipcurr),taur,rhoe,psi)
+          ENDIF
+          ! Randomize electronic wavefunctions around loaded ones
+          IF (cntl%trane) CALL rrane(c0(:,:,ipx:ipx),c2,crge%n)
+          ! Orthogonalize electronic wavefunctions
+          IF (irec(irec_wf,ipcurr).EQ.0.OR.cntl%trane.OR.(pslo_com%tivan.AND..NOT.cntl%nonort)) THEN
+             IF (pslo_com%tivan) CALL rnlsm(c0(:,:,ipx),crge%n,1,1,.FALSE.)
+             CALL ortho(crge%n,c0(:,:,ipx),c2)
+          ENDIF
+          ! ..Store occupation numbers in fall
+          CALL dcopy(crge%n*nkpt%nkpts,crge%f,1,fall(1,ipx),1)
+          ! ..Store WF history in coldall
+          IF (cntl%textrap.AND.np_local>1) THEN
+             CALL zcopy(nkpt%ngwk*crge%n*nkpt%nkpnt*cnti%mextra,cold,1,&
+                  coldall(1,1,1,1,ipx),1)
+             nnowall(ipx)=nnow; numcoldall(ipx)=numcold
+          ENDIF
        ENDIF
-       ! ..Store occupation numbers in fall
-       CALL dcopy(crge%n*nkpt%nkpts,crge%f,1,fall(1,ipx),1)
-       ! ..Store WF history in coldall
-       IF (cntl%textrap.AND.np_local>1) THEN
-          CALL zcopy(nkpt%ngwk*crge%n*nkpt%nkpnt*cnti%mextra,cold,1,&
-               coldall(1,1,1,1,ipx),1)
-          nnowall(ipx)=nnow; numcoldall(ipx)=numcold
-       ENDIF
     ENDDO
     ! ..Update cell
     IF (restart1%rcell) THEN
@@ -446,15 +447,18 @@
        CALL ihmat(metr_com%ht,metr_com%htm1,parm%omega)
        CALL newcell
     ENDIF
+    ! ..Initialize replica coordinates if requested
+    IF (.NOT.restart1%restart) THEN
+       IF (pimd1%tinit) THEN
+          CALL initrep(pitaup)
+       ELSE
+          CALL stopgm(procedureN,'replica coordinates not read/generated',&
+             __LINE__,__FILE__)
+       ENDIF
+    ENDIF
     ! ..Global distribution of ionic positions
     CALL global(pitaup,3*maxsys%nax*maxsys%nsx)
     CALL mp_bcast(pitaup,SIZE(pitaup),parai%io_source,parai%cp_grp)
-    DO ipcurr=np_low,np_high
-       IF (irec(irec_wf,ipcurr).EQ.0) THEN
-          ipx=ipcurr-np_low+1
-          CALL rinitwf(c0(:,:,ipx:ipx),c2,sc0,crge%n,pitaup(:,:,:,ipcurr),taur,rhoe,psi)
-       ENDIF
-    ENDDO
     IF (paral%parent) THEN
        IF (pimd1%tstage) THEN
           CALL stagetrans(pitaup,stagep,0)
@@ -472,6 +476,29 @@
     DO ipcurr=np_low,np_high
        ipx=ipcurr-np_low+1
        CALL phfac(pitaup(:,:,:,ipcurr))
+       ! ..Read WF centers & spread from restart file
+       IF (vdwl%vdwd) THEN
+          IF (paral%io_parent) THEN
+             nwfc=crge%n
+             vdwwfl%trwannc=trwanncx(ipx)
+             CALL rwannier(nwfc,tauref(:,:,:,ipx),rwann(:,:,ipx),swann(:,ipx),&
+                  vdwwfl%trwannc)
+             IF (.NOT.vdwwfl%trwannc) THEN
+                CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),1,&
+                     tauref(1,1,1,ipx),1)
+             ENDIF
+          ENDIF
+          CALL mp_bcast(tauref(:,:,:,ipx),3*maxsys%nax*maxsys%nsx,&
+               parai%io_source,parai%cp_grp)
+          CALL mp_bcast(rwann(:,:,ipx),3*nwfcx*nfragx,parai%io_source,parai%cp_grp)
+          CALL mp_bcast(swann(:,ipx),nwfcx*nfragx,parai%io_source,parai%cp_grp)
+          CALL mp_bcast(vdwwfl%trwannc,parai%io_source,parai%cp_grp)
+          trwanncx(ipx)=vdwwfl%trwannc
+       ENDIF
+       ! ..Initialization of wavefunction
+       IF (.NOT.restart1%restart) THEN
+          CALL rinitwf(c0(:,:,ipx:ipx),c2,sc0,crge%n,pitaup(:,:,:,ipcurr),taur,rhoe,psi)
+       ENDIF
        ! ..Initialize velocities
        IF (.NOT.restart1%rvel) THEN
           ener_com%ecnstr = 0.0_real_8
@@ -550,25 +577,29 @@
        ipx=ipcurr-np_low+1
        CALL phfac(pitaup(:,:,:,ipcurr))
        IF (corel%tinlc) CALL copot(rhoe,psi,.TRUE.)
-       IF (pslo_com%tivan) THEN
-          DO ik=1,nkpt%nkpnt
-             CALL rnlsm(c0(:,ipx:ipx+crge%n-1,ik),crge%n,1,ik,.FALSE.)
-          ENDDO
-       ENDIF
-       IF (irec(irec_rho,ipcurr).EQ.0) THEN
-          ! ..Restore occupation numbers
-          CALL dcopy(crge%n*nkpt%nkpts,fall(1,ipx),1,crge%f,1)
-          IF (tkpts%tkpnt) THEN
-             CALL rhoofr_c(c0(:,:,ipx),rhoe,psi(:,1),crge%n)
+       ! Initialization of density and potential
+       ! for diagonalization schemes
+       IF (cntl%tdiag) THEN
+          IF (pslo_com%tivan) THEN
+             CALL rnlsm(c0(:,:,ipx),crge%n,1,1,.FALSE.)
+          ENDIF
+          IF (irec(irec_rho,ipcurr).EQ.0) THEN
+             ! ..Restore occupation numbers
+             IF (restart1%restart) THEN
+                CALL dcopy(crge%n*nkpt%nkpts,fall(1,ipx),1,crge%f,1)
+             ENDIF
+             IF (tkpts%tkpnt) THEN
+                CALL rhoofr_c(c0(:,:,ipx),rhoe,psi(:,1),crge%n)
+             ELSE
+                CALL rhoofr(c0(:,:,ipx),rhoe,psi(:,1),crge%n)
+             ENDIF
+             CALL dcopy(nnx,rhoe,1,rin0,1)
           ELSE
-             CALL rhoofr(c0(:,:,ipx),rhoe,psi(:,1),crge%n)
+             CALL dcopy(nnx,rall(1,ipx),1,rin0,1)
           ENDIF
-          CALL dcopy(nnx,rhoe,1,rin0,1)
-       ELSE
-          IF (cntl%tdiag) CALL dcopy(nnx,rall(1,ipx),1,rin0,1)
+          ! NON LOCAL PROJECTOR OVERLAP MATRIX
+          IF (fint1%ttrot) CALL calc_alm
        ENDIF
-       ! NON LOCAL PROJECTOR OVERLAP MATRIX
-       IF (fint1%ttrot) CALL calc_alm
        ! INITIALIZE WF CENTERS & SPREAD
        IF (vdwl%vdwd) THEN
           IF (.NOT.trwanncx(ipx)) THEN
@@ -613,9 +644,9 @@
                 irec(irec_nop3,ipcurr)+irec(irec_nop4,ipcurr)
           IF (cntl%tnosep .AND. itemp.EQ.0) CALL nospinit(ipcurr)
           IF (cntl%tnosec .AND. irec(irec_noc,ipcurr).EQ.0) CALL noscinit(ipcurr)
-          ! ..Centroid PICPMD: Reset thermostat variables in case of
+          ! ..Centroid & Ring-polymer PIMD: Reset thermostat variables in case of
           ! ..a centroid restart from a non-centroid thermosatted run
-          IF (cntl%tnosep.AND.pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF (cntl%tnosep.AND.(pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              nrepl=maxnp
              IF (nosl%tultra) THEN
                 ! ..Not used with PICPMD 
@@ -625,8 +656,20 @@
                 CALL stopgm(procedureN,'LOCAL TEMPERATURE NOT IMPLEMENTED',& 
                      __LINE__,__FILE__)
              ELSEIF (nosl%tmnose) THEN
-                CALL stopgm(procedureN,'Massive NHCs thermostat not available for ip=1',&
-                     __LINE__,__FILE__)
+                IF (pimd1%tcentro) THEN
+                   CALL stopgm(procedureN,'Massive NHCs thermostat not available for ip=1',&
+                        __LINE__,__FILE__)
+                ELSE
+                   ! ..Switch off if requested
+                   IF (.NOT.tnosepc) THEN
+                      DO k=1,3*maxsys%nax*maxsys%nsx
+                         DO l=1,nchx
+                            etapm(k,l,1)=0._real_8
+                            etapmdot(k,l,1)=0._real_8
+                         ENDDO
+                      ENDDO
+                   ENDIF
+                ENDIF
              ELSE
                 ! ..Switch off if requested
                 IF (.NOT.tnosepc) THEN
@@ -738,7 +781,7 @@
                   __LINE__,__FILE__)
           ENDIF
           IF (reset_gkt.AND.ipcurr==1) gkt(1:2,1)=scr(1:2)
-          IF (pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF ((pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              IF (pimd1%tstage.OR.pimd1%tpinm) THEN
                 ! SUBTRACT CENTER OF MASS VELOCITY
                 IF (paral%parent.AND.comvl%subcom) THEN
@@ -947,7 +990,7 @@
                 ENDIF
              ENDIF
           ENDIF
-          IF (pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF ((pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              IF (pimd1%tstage.OR.pimd1%tpinm) THEN
                 ! SUBTRACT ROTATION AROUND CENTER OF MASS
                 IF (paral%parent.AND.comvl%subrot) THEN
@@ -1070,12 +1113,12 @@
              CALL prtgyr
              IF (paral%io_parent)&
                   WRITE(6,'(/,A,A)')&
-                  '    NFI   IP  TEMPP     EHARM         EKS',&
+                  '      NFI   IP  TEMPP     EHARM         EKS',&
                   '    ENOSE(C)    ENOSE(P)    ECLASSIC     DIS'
              DO ip=1,pimd3%np_total
                 IF (paral%io_parent)&
                      WRITE(6,&
-                     '(I7,I5,F7.1,F10.6,F12.5,2(2X,F10.5),F12.5, F8.2)')&
+                     '(I9,I5,F7.1,F10.6,F12.5,2(2X,F10.5),F12.5, F8.2)')&
                      iteropt%nfi,ip,tempp(ip),eharv(ip),etotv(ip),&
                      enosc(ip),enosp(ip),econs(ip),disa(ip)
              ENDDO
@@ -1112,13 +1155,13 @@
           tcpu=(time2-time1)*0.001_real_8
           IF ((ropt_mod%engpri).AND.paral%io_parent)&
                WRITE(6,'(/,A,A)')&
-               '    NFI    EKINH  TEMP  EKINP(P)  EKINP(V)       EKS/P',&
+               '      NFI    EKINH  TEMP  EKINP(P)  EKINP(V)       EKS/P',&
                '       EQUANT     ECLASSIC         EHAM     TCPU'
           IF (paral%io_parent)&
-               WRITE(6,'(I7,F9.5,F7.1,2F9.5,4F13.5,F9.2)')&
+               WRITE(6,'(I9,F9.5,F7.1,2F9.5,4F13.5,F9.2)')&
                iteropt%nfi,ekinh,tempa,qpkinp,qvkinp,etota,equant,econsa,ehama,tcpu
           IF (paral%io_parent)&
-               WRITE(3,'(I7,F9.5,F7.1,2F9.5,4F20.10,F9.2)')&
+               WRITE(3,'(I9,F9.5,F7.1,2F9.5,4F20.10,F9.2)')&
                iteropt%nfi,ekinh,tempa,qpkinp,qvkinp,etota,equant,econsa,ehama,tcpu
           ! ..Store ionic coordinates and velocities for statistics
           ropt_mod%movie=rout1%mout .AND. MOD(iteropt%nfi-1,cnti%imovie).EQ.0
@@ -1138,7 +1181,7 @@
        IF (infi.EQ.cnti%nomore) soft_com%exsoft=.TRUE.
 
        nosl%tmnose=pitmnose(2)  ! recover original setup of tmnose
-       IF ((pimd1%tstage.OR.pimd1%tpinm).AND.nosl%tmnose) CALL wr_temps(iteropt%nfi,ekinc,tempp)
+       IF (pimd1%tstage.OR.pimd1%tpinm) CALL wr_temps(iteropt%nfi,ekinc,tempp)
        ! ..Recompute velocity-dependent part of pipaiu
        IF (pimd1%tstage.OR.pimd1%tpinm) THEN
           pipaiu=pi_stress_vir(paiuall,stagep(:,:,:,1),vstage(:,:,:,1),pitaup,fionks,.TRUE.)
Index: src/pi_npt_cpmd_utils.mod.F90
===================================================================
--- src/pi_npt_cpmd_utils.mod.F90	(revision 4634)
+++ src/pi_npt_cpmd_utils.mod.F90	(revision 4635)
@@ -84,6 +84,7 @@
   USE pinmtrans_utils,                 ONLY: pinmtrans
   USE pi_stress_utils,                 ONLY: pi_stress_vir,&
                                              wr_pi_stress
+  USE pi_wf_utils,                     ONLY: initrep
   USE posupa_utils,                    ONLY: posupa
   USE posupi_utils,                    ONLY: posupi,&
                                              posupih,&
@@ -97,6 +98,7 @@
   USE prtgyr_utils,                    ONLY: prtgyr
   USE pslo,                            ONLY: pslo_com
   USE puttau_utils,                    ONLY: taucl
+  USE quenbo_utils,                    ONLY: quenbo
   USE ranp_utils,                      ONLY: ranp
   USE rattle_utils,                    ONLY: rattle
   USE readsr_utils,                    ONLY: xstring
@@ -103,6 +105,7 @@
   USE rekine_utils,                    ONLY: rekine
   USE reshaper,                        ONLY: reshape_inplace
   USE rhopri_utils,                    ONLY: rhopri
+  USE rinitwf_driver,                  ONLY: rinitwf
   USE rinvel_utils,                    ONLY: rinvel,&
                                              rvscal,&
                                              s_rinvel
@@ -332,52 +335,41 @@
        nosl%tmnose=pitmnose(MIN(ipcurr,2))
        cntl%tnosec=pitnosec(MIN(ipcurr,2))
        CALL read_irec(irec(:,ipcurr))
-       ! ..Construct filenames
-       cflbod='RESTART_'
-       IF (paral%io_parent)&
-            WRITE(cipnum,'(I4)') ipcurr
-       CALL xstring(cflbod,n1,n2)
-       CALL xstring(cipnum,i1,i2)
-       filbod=cflbod(n1:n2)//cipnum(i1:i2)//'.1'
-       IF (restart1%rlate) THEN
-          filn=filbod
-       ELSE
-          filn=cflbod(n1:n2)//cipnum(i1:i2)
-       ENDIF
-       ! ..Read restart file
-       ipx=ipcurr-np_low+1
-       CALL zhrwf(1,irec(:,ipcurr),c0(:,:,ipx:ipx),cm(:,:,ipx),crge%n,eigv(:,ipx),&
-            pitaup(:,:,:,ipcurr),&
-            pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),iteropt%nfi)
-       CALL dcopy(nacc,acc,1,accus(1,ipcurr),1)
-       IF (restart1%rgeo) THEN
-          IF (paral%io_parent) CALL geofile(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),'READ')
-          CALL mp_bcast(pitaup(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(pivelp(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(metr_com%ht,SIZE(metr_com%ht),parai%io_source,parai%cp_grp)
-          CALL mp_bcast(metr_com%htvel,SIZE(metr_com%htvel),parai%io_source,parai%cp_grp)
-          restart1%rcell=.TRUE.; restart1%rvel=.TRUE.
-       ENDIF
-       ! ..Randomization of the atomic coordinates
-       IF (cntl%tranp.AND.paral%parent) CALL ranp(pitaup(:,:,:,ipcurr))
-       ! Read WF centers & spread from restart file
-       IF (vdwl%vdwd) THEN
-          IF (paral%io_parent) THEN
-             nwfc=crge%n
-             vdwwfl%trwannc=trwanncx(ipx)
-             CALL rwannier(nwfc,tauref(:,:,:,ipx),rwann(:,:,ipx),swann(:,ipx),&
-                  vdwwfl%trwannc)
-             IF (.NOT.vdwwfl%trwannc) THEN
-                CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),&
-                     1,tauref(1,1,1,ipx),1)
-             ENDIF
+       IF (restart1%restart) THEN
+          ! ..Construct filenames
+          cflbod='RESTART_'
+          IF (paral%io_parent)&
+               WRITE(cipnum,'(I4)') ipcurr
+          CALL xstring(cflbod,n1,n2)
+          CALL xstring(cipnum,i1,i2)
+          filbod=cflbod(n1:n2)//cipnum(i1:i2)//'.1'
+          IF (restart1%rlate) THEN
+             filn=filbod
+          ELSE
+             filn=cflbod(n1:n2)//cipnum(i1:i2)
           ENDIF
-          CALL mp_bcast(tauref(:,:,:,ipx),3*maxsys%nax*maxsys%nsx,&
-               parai%io_source,parai%cp_grp)
-          CALL mp_bcast(rwann(:,:,ipx),3*nwfcx*nfragx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(swann(:,ipx),nwfcx*nfragx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(vdwwfl%trwannc,parai%io_source,parai%cp_grp)
-          trwanncx(ipx)=vdwwfl%trwannc
+          ! ..Read restart file
+          ipx=ipcurr-np_low+1
+          CALL zhrwf(1,irec(:,ipcurr),c0(:,:,ipx:ipx),cm(:,:,ipx),crge%n,eigv(:,ipx),&
+               pitaup(:,:,:,ipcurr),&
+               pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),iteropt%nfi)
+          CALL dcopy(nacc,acc,1,accus(1,ipcurr),1)
+          IF (restart1%rgeo) THEN
+             IF (paral%io_parent) CALL geofile(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),'READ')
+             CALL mp_bcast(pitaup(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
+             CALL mp_bcast(pivelp(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
+             CALL mp_bcast(metr_com%ht,SIZE(metr_com%ht),parai%io_source,parai%cp_grp)
+             CALL mp_bcast(metr_com%htvel,SIZE(metr_com%htvel),parai%io_source,parai%cp_grp)
+             restart1%rcell=.TRUE.; restart1%rvel=.TRUE.
+          ENDIF
+          ! ..Randomization of the atomic coordinates
+          IF (cntl%tranp.AND.paral%parent) CALL ranp(pitaup(:,:,:,ipcurr))
+          ! ..Initialization of wavefunction
+          IF (irec(irec_wf,ipcurr).EQ.0) THEN
+             CALL rinitwf(c0(:,:,ipx:ipx),cm,sc0,crge%n,pitaup(:,:,:,ipcurr),&
+                  taur,rhoe,psi)
+             cntl%quenchb=.TRUE.
+          ENDIF
        ENDIF
     ENDDO
     ! ..Update cell
@@ -395,6 +387,16 @@
        CALL ihmat(metr_com%ht,metr_com%htm1,parm%omega)
        CALL newcell
     ENDIF
+    ! ..Initialize replica coordinates if requested
+    IF (.NOT.restart1%restart) THEN
+       IF (pimd1%tinit) THEN
+          CALL initrep(pitaup)
+          cntl%quenchb=.TRUE.
+       ELSE
+          CALL stopgm(procedureN,'replica coordinates not read/generated',&
+             __LINE__,__FILE__)
+       ENDIF
+    ENDIF
     ! ..Global distribution of ionic positions
     CALL global(pitaup,3*maxsys%nax*maxsys%nsx)
     CALL mp_bcast(pitaup,SIZE(pitaup),parai%io_source,parai%cp_grp)
@@ -413,14 +415,37 @@
        glib=1._real_8
     ENDIF
     DO ipcurr=np_low,np_high
-       IF (irec(irec_wf,ipcurr).EQ.0) THEN
-          CALL stopgm(procedureN,'RESTARTS WITH WAVEFUNCTIONS ONLY',&
-               __LINE__,__FILE__)
-       ENDIF
-    ENDDO
-    DO ipcurr=np_low,np_high
        ipx=ipcurr-np_low+1
        CALL phfac(pitaup(:,:,:,ipcurr))
+       ! ..Read WF centers & spread from restart file
+       IF (vdwl%vdwd) THEN
+          IF (paral%io_parent) THEN
+             nwfc=crge%n
+             vdwwfl%trwannc=trwanncx(ipx)
+             CALL rwannier(nwfc,tauref(:,:,:,ipx),rwann(:,:,ipx),swann(:,ipx),&
+                  vdwwfl%trwannc)
+             IF (.NOT.vdwwfl%trwannc) THEN
+                CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),1,&
+                     tauref(1,1,1,ipx),1)
+             ENDIF
+          ENDIF
+          CALL mp_bcast(tauref(:,:,:,ipx),3*maxsys%nax*maxsys%nsx,&
+               parai%io_source,parai%cp_grp)
+          CALL mp_bcast(rwann(:,:,ipx),3*nwfcx*nfragx,parai%io_source,parai%cp_grp)
+          CALL mp_bcast(swann(:,ipx),nwfcx*nfragx,parai%io_source,parai%cp_grp)
+          CALL mp_bcast(vdwwfl%trwannc,parai%io_source,parai%cp_grp)
+          trwanncx(ipx)=vdwwfl%trwannc
+       ENDIF
+       ! ..Initialization of wavefunction
+       IF (.NOT.restart1%restart) THEN
+          CALL rinitwf(c0(:,:,ipx:ipx),cm,sc0,crge%n,pitaup(:,:,:,ipcurr),&
+               taur,rhoe,psi)
+       ENDIF
+       ! ..Quenching to BO surface
+       IF (cntl%quenchb) THEN
+          CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),1,tau0,1)
+          CALL quenbo(c0(:,:,ipx),c2(1,1,ipx),sc0,taur,rhoe,psi)
+       ENDIF
        IF (pslo_com%tivan) THEN
           IF (cntl%tlsd) THEN
              CALL deort(ncpw%ngw,spin_mod%nsup,eigm(1,ipx),eigv(1,ipx),&
@@ -532,9 +557,9 @@
           IF (cntl%tnosee .AND. .NOT.restart1%rnoe) CALL noseinit(ipcurr)
           IF (cntl%tnosec .AND. irec(irec_noc,ipcurr).EQ.0) CALL noscinit(ipcurr)
           ! DM1
-          ! ..Centroid PICPMD: Reset thermostat variables in case of 
+          ! ..Centroid & Ring-polmer PIMD: Reset thermostat variables in case of 
           ! ..a centroid restart from a non-centroid thermosatted run
-          IF (cntl%tnosep.AND.pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF (cntl%tnosep.AND.(pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              nrepl=maxnp
              IF (nosl%tultra) THEN
                 ! ..Not used with PICPMD 
@@ -544,8 +569,20 @@
                 CALL stopgm(procedureN,'LOCAL TEMEPERATURE NOT IMPLEMENTED',& 
                      __LINE__,__FILE__)
              ELSEIF (nosl%tmnose) THEN
-                CALL stopgm(procedureN,'Massive NHCs thermostat not available for ip=1',&
-                     __LINE__,__FILE__)
+                IF (pimd1%tcentro) THEN
+                   CALL stopgm(procedureN,'Massive NHCs thermostat not available for ip=1',&
+                        __LINE__,__FILE__)
+                ELSE
+                   ! ..Switch off if requested
+                   IF (.NOT.tnosepc) THEN
+                      DO k=1,3*maxsys%nax*maxsys%nsx
+                         DO l=1,nchx
+                            etapm(k,l,1)=0._real_8
+                            etapmdot(k,l,1)=0._real_8
+                         ENDDO
+                      ENDDO
+                   ENDIF
+                ENDIF
              ELSE
                 ! ..Switch off if requested
                 IF (.NOT.tnosepc) THEN
@@ -661,7 +698,7 @@
                   __LINE__,__FILE__)
           ENDIF
           IF (reset_gkt.AND.ipcurr==1) gkt(1:2,1)=scr(1:2)
-          IF (pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF ((pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              IF (pimd1%tstage.OR.pimd1%tpinm) THEN
                 ! SUBTRACT CENTER OF MASS VELOCITY
                 IF (paral%parent.AND.comvl%subcom) THEN
@@ -860,7 +897,7 @@
                 ! DM2ra
              ENDIF
           ENDIF
-          IF (pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF ((pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              IF (pimd1%tstage.OR.pimd1%tpinm) THEN
                 ! SUBTRACT ROTATION AROUND CENTER OF MASS
                 IF (paral%parent.AND.comvl%subrot) THEN
@@ -995,12 +1032,12 @@
              CALL prtgyr
              IF (paral%io_parent)&
                   WRITE(6,'(/,A,A)')&
-                  '    NFI   IP   EKINC  TEMPP     EHARM         EKS',&
+                  '      NFI   IP   EKINC  TEMPP     EHARM         EKS',&
                   '  ENOSE(C)  ENOSE(E)  ENOSE(P)    ECLASSIC        EHAM     DIS'
              DO ip=1,pimd3%np_total
                 IF (paral%io_parent)&
                      WRITE(6,&
-                     '(I7,I5,F8.5,F7.1,F10.6,F12.5,3F10.5,2F12.5,F8.2)')&
+                     '(I9,I5,F8.5,F7.1,F10.6,F12.5,3F10.5,2F12.5,F8.2)')&
                      iteropt%nfi,ip,ekinc(ip),tempp(ip),eharv(ip),etotv(ip),&
                      enosc(ip),enose(ip),enosp(ip),econs(ip),eham(ip),disa(ip)
              ENDDO
@@ -1041,13 +1078,13 @@
           tcpu=(time2-time1)*0.001_real_8
           IF ((ropt_mod%engpri).AND.paral%io_parent)&
                WRITE(6,'(/,A,A)')&
-               '    NFI  EKINC/P    EKINH  TEMP  EKINP(P)  EKINP(V)       EKS/P',&
+               '      NFI  EKINC/P    EKINH  TEMP  EKINP(P)  EKINP(V)       EKS/P',&
                '       EQUANT     ECLASSIC         EHAM     TCPU'
           IF (paral%io_parent)&
-               WRITE(6,'(I7,2F9.5,F7.1,2F9.5,4F13.5,F9.2)')&
+               WRITE(6,'(I9,2F9.5,F7.1,2F9.5,4F13.5,F9.2)')&
                iteropt%nfi,ekina,ekinh,tempa,qpkinp,qvkinp,etota,equant,econsa,ehama,tcpu
           IF (paral%io_parent)&
-               WRITE(3,'(I7,2F15.10,F7.1,6F20.10,F9.2)')&
+               WRITE(3,'(I9,2F15.10,F7.1,6F20.10,F9.2)')&
                iteropt%nfi,ekina,ekinh,tempa,qpkinp,qvkinp,etota,equant,econsa,ehama,tcpu
           ! ..Store ionic coordinates and velocities for statistics
           ropt_mod%movie=rout1%mout .AND. MOD(iteropt%nfi-1,cnti%imovie).EQ.0
@@ -1067,7 +1104,7 @@
        IF (infi.EQ.cnti%nomore) soft_com%exsoft=.TRUE.
        ! new
        nosl%tmnose=pitmnose(2)  ! recover original setup of tmnose
-       IF ((pimd1%tstage.OR.pimd1%tpinm).AND.nosl%tmnose) CALL wr_temps(iteropt%nfi,ekinc,tempp)
+       IF (pimd1%tstage.OR.pimd1%tpinm) CALL wr_temps(iteropt%nfi,ekinc,tempp)
        ! new
        ! ..Recompute velocity-dependent part of pipaiu
        IF (pimd1%tstage.OR.pimd1%tpinm) THEN
Index: src/pi_diag_utils.mod.F90
===================================================================
--- src/pi_diag_utils.mod.F90	(revision 4634)
+++ src/pi_diag_utils.mod.F90	(revision 4635)
@@ -43,6 +43,13 @@
   USE getfnm_utils,                    ONLY: getfnm
   USE getfu_utils,                     ONLY: getfu
   USE getgyr_utils,                    ONLY: getgyration
+  USE glemod,                          ONLY: glepar,&
+                                             glec,&
+                                             gles,&
+                                             glet,&
+                                             glep
+  USE gle_utils,                       ONLY: gle_init,&
+                                             gle_step
   USE global_utils,                    ONLY: global
   USE ions,                            ONLY: ions1
   USE kinds,                           ONLY: real_8
@@ -56,6 +63,8 @@
   USE moverho_utils,                   ONLY: moverho
   USE mp_interface,                    ONLY: mp_bcast,&
                                              mp_sync
+! USE interface_utils,                 ONLY: get_external_forces
+  USE mts_utils,                       ONLY: mts, set_mts_functional
   USE nlcc,                            ONLY: corel,&
                                              vnlcc,&
                                              vnlt
@@ -74,24 +83,33 @@
   USE nosepa_utils,                    ONLY: nosepa
   USE noseup_utils,                    ONLY: noseup
   USE nospinit_utils,                  ONLY: nospinit
+  USE ortho_utils,                     ONLY: ortho
   USE parac,                           ONLY: parai,&
                                              paral
   USE phfac_utils,                     ONLY: phfac
   USE pi_md_utils,                     ONLY: disten,&
-                                             pi_ener
+                                             pi_ener,&
+                                             gleback
   USE pimd,                            ONLY: &
        eharv, etotv, fionks, grandparent, ipcurr, maxnp, np_high, np_local, &
-       np_low, pimd1, pimd3, supergroup
+       np_low, pimd1, pimd3, supergroup, pma0s, pi_egle, pi_glec, pi_gles, &
+       pi_glet, pi_glep
   USE pinmtrans_utils,                 ONLY: pinmtrans
   USE pi_stress_utils,                 ONLY: pi_stress_vir,&
                                              pi_stress_nmm,&
                                              pi_stress_pri,&
                                              wr_pi_stress
+  USE pi_wf_utils,                     ONLY: initrep
   USE poin,                            ONLY: rhoo
   USE posupi_utils,                    ONLY: posupi
   USE printave_utils,                  ONLY: paccd
-  USE printp_utils,                    ONLY: printp
+  USE printp_utils,                    ONLY: printp,&
+                                             print_mts_forces
   USE prmem_utils,                     ONLY: prmem
+  USE prng,                            ONLY: prng_com,&
+                                             pi_prng_com
+  USE prng_utils,                      ONLY: prnginit,&
+                                             repprngu_vec
   USE prtgyr_utils,                    ONLY: prtgyr
   USE pslo,                            ONLY: pslo_com
   USE puttau_utils,                    ONLY: taucl
@@ -105,11 +123,13 @@
   USE rinvel_utils,                    ONLY: rinvel,&
                                              rvscal,&
                                              s_rinvel
+  USE rmas,                            ONLY: rmass
   USE rnlsm_utils,                     ONLY: rnlsm
   USE ropt,                            ONLY: infi,&
                                              iteropt,&
                                              ropt_mod
   USE rotvel_utils,                    ONLY: rotvel
+  USE rrane_utils,                     ONLY: rrane
   USE rscvp_utils,                     ONLY: rscvp
   USE rv30_utils,                      ONLY: zhrwf
   USE setirec_utils,                   ONLY: read_irec,&
@@ -120,10 +140,10 @@
   USE stagetrans_utils,                ONLY: stagetrans
   USE store_types,                     ONLY: &
        cprint, iprint_coor, iprint_force, irec_nop1, irec_nop2, irec_nop3, &
-       irec_nop4, irec_rho, irec_wf, restart1, rout1
+       irec_nop4, irec_rho, irec_wf, irec_prng, irec_co, restart1, rout1
   USE strs,                            ONLY: paiu
   USE system,                          ONLY: &
-       acc, cnti, cntl, cntr, fpar, maxsys, nacc, nacx, nkpt, restf, ncpw
+       acc, cnti, cntl, cntr, fpar, maxsys, nacc, nacx, nkpt, restf, ncpw, iatpt
   USE testex_utils,                    ONLY: testex,&
                                              testex_mw
   USE teststore_utils,                 ONLY: teststore
@@ -163,15 +183,18 @@
     CHARACTER(len=100)                       :: filen
     CHARACTER(len=12)                        :: cflbod, cipnum
     CHARACTER(len=30)                        :: tag
-    COMPLEX(real_8), ALLOCATABLE             :: coldall(:,:,:,:,:), psi(:,:)
+    COMPLEX(real_8), ALLOCATABLE             :: coldall(:,:,:,:,:), &
+                                                coldall_high(:,:,:,:,:), &
+                                                psi(:,:)
     INTEGER :: i, i1, i2, ierr, ifcalc, ik, il_psi_1d, il_psi_2d, il_rhoe_1d, &
       il_rhoe_2d, ip, ipx, itemp, k, l, lenext, lscr, n1, n2, nnx, &
-      npx, nrepl, nwfc, nx
+      npx, nrepl, nwfc, nx, iprng0
     INTEGER, ALLOCATABLE                     :: nnowall(:), numcoldall(:), &
+                                                nnowall_high(:), numcoldall_high(:), &
                                                 irec(:,:)
     LOGICAL                                  :: ferror, reset_gkt, &
                                                 pitmnose(2)
-    REAL(real_8) :: accus(nacx,maxnp), d1, d2, disa(maxnp), dummies(1), &
+    REAL(real_8) :: accus(nacx,maxnp), d1, d2, disa(maxnp), dummies(maxnp), &
       dummy, dummy2, econs(maxnp), econsa, eham(maxnp), ehama, ekin1, ekin2, ekina, &
       ekinc(maxnp), ekincp, ekinh1, ekinh2, ekinp, enose(maxnp), &
       enosp(maxnp), equant, etota, glib_s, lmio(3), qpkinp, qvkinp, rmem, &
@@ -183,6 +206,16 @@
     REAL(real_8), POINTER                    :: pifion(:,:,:,:), &
                                                 pitaup(:,:,:,:), &
                                                 pivelp(:,:,:,:)
+    ! MTS[
+    ! number of inner steps between two large steps and total number of large steps
+    integer :: n_inner_steps, n_large_steps
+    ! logical to know if the current step is a large step in the MTS scheme
+    logical :: mts_large_step, mts_pure_dft
+    ! high level ionic forces
+    real(real_8), allocatable :: fion_high(:,:,:)
+    ! high level wave-function parameters
+    complex(real_8), allocatable :: c0_high(:,:,:)
+    ! MTS]
 
     accus=0.0_real_8
     disa=0.0_real_8
@@ -194,6 +227,26 @@
     tempp=0.0_real_8
     restf%nfnow=1
     time1 =m_walltime()
+
+    mts_pure_dft = .false.
+    if (cntl%use_mts) then
+
+       ! allocate high level forces array
+       allocate(fion_high(3,maxsys%nax,maxsys%nsx),stat=ierr)
+       if(ierr/=0) call stopgm(proceduren,'allocation problem: fion_high',&
+          __LINE__,__FILE__)
+       call zeroing(fion_high)
+
+       ! allocate high level WF param array only if needed
+       mts_pure_dft = ( (mts%low_level == 'DFT') .and. (mts%high_level == 'DFT') )
+       if (mts_pure_dft) then
+          allocate( c0_high(size(c0,1),size(c0,2),size(c0,3)), stat=ierr )
+          if(ierr/=0) call stopgm(proceduren,'allocation problem : c0_high',&
+             __LINE__,__FILE__)
+       end if
+
+    end if
+
     npx=pimd3%np_total
     rnp=REAL(npx,kind=real_8)
     ALLOCATE(taup(3,maxsys%nax,maxsys%nsx*npx),STAT=ierr)
@@ -308,21 +361,67 @@
        ALLOCATE(cold(nkpt%ngwk,crge%n,nkpt%nkpnt,lenext/(crge%n*nkpt%ngwk*nkpt%nkpnt)),STAT=ierr)
        IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
             __LINE__,__FILE__)
-       IF (paral%io_parent)&
-            WRITE(6,'(A,T51,F8.3,A)') ' PI_DIAG| '&
-            // 'EXTRAPOLATION WAVEFUNCTION HISTORY TAKES ',rmem,' MBYTES'
+       call zeroing(cold)
        IF (np_local>1) THEN
           ALLOCATE(coldall(nkpt%ngwk,crge%n,nkpt%nkpnt,cnti%mextra,np_local),STAT=ierr)
           IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
                __LINE__,__FILE__)
+          call zeroing(coldall)
           ALLOCATE(nnowall(np_local),STAT=ierr)
           IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
                __LINE__,__FILE__)
+          call zeroing(nnowall)
           ALLOCATE(numcoldall(np_local),STAT=ierr)
           IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
                __LINE__,__FILE__)
+          call zeroing(numcoldall)
+          rmem=rmem+rmem*REAL(np_local,kind=real_8)
        ENDIF
+
+       ! allocate array for high level WF extrapolation
+       if (mts_pure_dft) then
+          allocate(coldall_high(nkpt%ngwk,crge%n,nkpt%nkpnt,cnti%mextra,np_local),stat=ierr)
+          if(ierr/=0) call stopgm(proceduren,'allocation problem: coldall_high',&
+               __LINE__,__FILE__)
+          call zeroing(coldall_high)
+          allocate(nnowall_high(np_local),STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+            __LINE__,__FILE__)
+          call zeroing(nnowall_high)
+          allocate(numcoldall_high(np_local),STAT=ierr)
+          if(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+            __LINE__,__FILE__)
+          call zeroing(numcoldall_high)
+          rmem=rmem+rmem*REAL(np_local,kind=real_8)
+       endif
+
+       IF (paral%io_parent)&
+            WRITE(6,'(A,T51,F8.3,A)') ' PI_DIAG| '&
+            // 'EXTRAPOLATION WAVEFUNC. HISTORY TAKES ',rmem,' MBYTES'
     ENDIF
+
+    ALLOCATE(pi_egle(npx),STAT=ierr)
+    IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+         __LINE__,__FILE__)
+    IF (np_local>1) THEN
+       ALLOCATE(pi_prng_com(np_local),STAT=ierr)
+       IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+            __LINE__,__FILE__)
+       IF (glepar%gle_mode>0) THEN
+          ALLOCATE(pi_glec(np_local),STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+               __LINE__,__FILE__)
+          ALLOCATE(pi_gles((glepar%gle_ns+1)*(glepar%gle_ns+1),np_local),STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+               __LINE__,__FILE__)
+          ALLOCATE(pi_glet((glepar%gle_ns+1)*(glepar%gle_ns+1),np_local),STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+               __LINE__,__FILE__)
+          ALLOCATE(pi_glep(3,maxsys%nax,maxsys%nsx,(glepar%gle_ns+1),np_local),STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+               __LINE__,__FILE__)
+       ENDIF
+    ENDIF
     ! ==--------------------------------------------------------------==
     ! SCR ALLOCATION AND PARTITION (SCRATCH ARRAY).
     CALL rhoe_psi_size(il_rhoe_1d=il_rhoe_1d, il_rhoe_2d=il_rhoe_2d, &
@@ -354,78 +453,71 @@
     DO ipcurr=np_low,np_high
        nosl%tmnose=pitmnose(MIN(ipcurr,2))
        CALL read_irec(irec(:,ipcurr))
-       ! ..Construct filenames
-       cflbod='RESTART_'
-       IF (paral%io_parent)&
-            WRITE(cipnum,'(I4)') ipcurr
-       CALL xstring(cflbod,n1,n2)
-       CALL xstring(cipnum,i1,i2)
-       filbod=cflbod(n1:n2)//cipnum(i1:i2)//'.1'
-       IF (restart1%rlate) THEN
-          filn=filbod
-       ELSE
-          filn=cflbod(n1:n2)//cipnum(i1:i2)
-       ENDIF
-       ! ..Read restart file
-       ipx=ipcurr-np_low+1
-       CALL zhrwf(1,irec(:,ipcurr),c0(:,:,ipx:ipx),c2,crge%n,eigv(:,ipx),&
-            pitaup(:,:,:,ipcurr),&
-            pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),iteropt%nfi)
-       CALL dcopy(nacc,acc,1,accus(1,ipcurr),1)
-       IF (restart1%rgeo) THEN
-          IF (paral%io_parent) CALL geofile(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),'READ')
-          CALL mp_bcast(pitaup(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(pivelp(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
-          restart1%rvel=.TRUE.
-       ENDIF
-       IF (irec(irec_rho,ipcurr).NE.0) THEN
-          CALL dcopy(nnx,rhoo,1,rall(1,ipx),1)
-       ENDIF
-       ! ..Randomization of the atomic coordinates
-       IF (cntl%tranp.AND.paral%parent) CALL ranp(pitaup(:,:,:,ipcurr))
-       ! ..Read WF centers & spread from restart file
-       IF (vdwl%vdwd) THEN
-          IF (paral%io_parent) THEN
-             nwfc=crge%n
-             vdwwfl%trwannc=trwanncx(ipx)
-             CALL rwannier(nwfc,tauref(:,:,:,ipx),rwann(:,:,ipx),swann(:,ipx),&
-                  vdwwfl%trwannc)
-             IF (.NOT.vdwwfl%trwannc) THEN
-                CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),&
-                     1,tauref(1,1,1,ipx),1)
-             ENDIF
+       IF (restart1%restart) THEN
+          ! ..Construct filenames
+          cflbod='RESTART_'
+          IF (paral%io_parent)&
+               WRITE(cipnum,'(I4)') ipcurr
+          CALL xstring(cflbod,n1,n2)
+          CALL xstring(cipnum,i1,i2)
+          filbod=cflbod(n1:n2)//cipnum(i1:i2)//'.1'
+          IF (restart1%rlate) THEN
+             filn=filbod
+          ELSE
+             filn=cflbod(n1:n2)//cipnum(i1:i2)
           ENDIF
-          CALL mp_bcast(tauref(:,:,:,ipx),3*maxsys%nax*maxsys%nsx,&
-               parai%io_source,parai%cp_grp)
-          CALL mp_bcast(rwann(:,:,ipx),3*nwfcx*nfragx,parai%io_source,&
-               parai%cp_grp)
-          CALL mp_bcast(swann(:,ipx),nwfcx*nfragx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(vdwwfl%trwannc,parai%io_source,parai%cp_grp)
-          trwanncx(ipx)=vdwwfl%trwannc
+          ! ..Read restart file
+          ipx=ipcurr-np_low+1
+          CALL zhrwf(1,irec(:,ipcurr),c0(:,:,ipx:ipx),c2,crge%n,eigv(:,ipx),&
+               pitaup(:,:,:,ipcurr),&
+               pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),iteropt%nfi)
+          CALL dcopy(nacc,acc,1,accus(1,ipcurr),1)
+          IF (restart1%rgeo) THEN
+             IF (paral%io_parent) CALL geofile(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),'READ')
+             CALL mp_bcast(pitaup(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
+             CALL mp_bcast(pivelp(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
+             restart1%rvel=.TRUE.
+          ENDIF
+          IF (irec(irec_rho,ipcurr).NE.0) THEN
+             CALL dcopy(nnx,rhoo,1,rall(1,ipx),1)
+          ENDIF
+          ! ..Randomization of the atomic coordinates
+          IF (cntl%tranp.AND.paral%parent) CALL ranp(pitaup(:,:,:,ipcurr))
+          ! ..Initialization of wavefunction
+          IF (irec(irec_wf,ipcurr).EQ.0) THEN
+             CALL rinitwf(c0(:,:,ipx:ipx),c2,sc0,crge%n,pitaup(:,:,:,ipcurr),taur,rhoe,psi)
+          ENDIF
+          ! Randomize electronic wavefunctions around loaded ones
+          IF (cntl%trane) CALL rrane(c0(:,:,ipx:ipx),c2,crge%n)
+          ! Orthogonalize electronic wavefunctions
+          IF (irec(irec_wf,ipcurr).EQ.0.OR.cntl%trane.OR.(pslo_com%tivan.AND..NOT.cntl%nonort)) THEN
+             IF (pslo_com%tivan) CALL rnlsm(c0(:,:,ipx),crge%n,1,1,.FALSE.)
+             CALL ortho(crge%n,c0(:,:,ipx),c2)
+          ENDIF
+          ! ..Store occupation numbers in fall
+          CALL dcopy(crge%n*nkpt%nkpts,crge%f,1,fall(1,ipx),1)
+          ! ..Store WF history in coldall
+          IF (cntl%textrap.AND.np_local>1) THEN
+             CALL zcopy(nkpt%ngwk*crge%n*nkpt%nkpnt*cnti%mextra,cold,1,&
+                  coldall(1,1,1,1,ipx),1)
+             nnowall(ipx)=nnow; numcoldall(ipx)=numcold
+          ENDIF
+          ! ..Store GLE-related variables
+          CALL gleback(ipcurr,.FALSE.,0)
        ENDIF
-       ! ..Store occupation numbers in fall
-       CALL dcopy(crge%n*nkpt%nkpts,crge%f,1,fall(1,ipx),1)
-       ! ..Store WF history in coldall
-       IF (cntl%textrap.AND.np_local>1) THEN
-          CALL zcopy(nkpt%ngwk*crge%n*nkpt%nkpnt*cnti%mextra,cold,1,&
-               coldall(1,1,1,1,ipx),1)
-          nnowall(ipx)=nnow; numcoldall(ipx)=numcold
+    ENDDO
+    ! ..Initialize replica coordinates if requested
+    IF (.NOT.restart1%restart) THEN
+       IF (pimd1%tinit) THEN
+          CALL initrep(pitaup)
+       ELSE
+          CALL stopgm(procedureN,'replica coordinates not read/generated',&
+             __LINE__,__FILE__)
        ENDIF
-    ENDDO
-    ! ..Global distribution of occupation numbers
-    ! CALL dcopy(crge%n*nkpt%nkpts,crge%f,1,fall,1)
-    ! CALL global(fall,crge%n*nkpt%nkpts)  ! why call global?
+    ENDIF
     ! ..Global distribution of ionic positions
     CALL global(pitaup,3*maxsys%nax*maxsys%nsx)
     CALL mp_bcast(pitaup,SIZE(pitaup),parai%io_source,parai%cp_grp)
-    DO ipcurr=np_low,np_high
-       IF (irec(irec_wf,ipcurr).EQ.0) THEN
-       !  CALL stopgm('PI_DIAG','RESTARTS WITH WAVEFUNCTIONS ONLY',& 
-       !       __LINE__,__FILE__)
-          ipx=ipcurr-np_low+1
-          CALL rinitwf(c0(:,:,ipx:ipx),c2,sc0,crge%n,pitaup(:,:,:,ipcurr),taur,rhoe,psi)
-       ENDIF
-    ENDDO
     IF (paral%parent) THEN
        IF (pimd1%tstage) THEN
           CALL stagetrans(pitaup,stagep,0)
@@ -443,6 +535,29 @@
     DO ipcurr=np_low,np_high
        ipx=ipcurr-np_low+1
        CALL phfac(pitaup(:,:,:,ipcurr))
+       ! ..Read WF centers & spread from restart file
+       IF (vdwl%vdwd) THEN
+          IF (paral%io_parent) THEN
+             nwfc=crge%n
+             vdwwfl%trwannc=trwanncx(ipx)
+             CALL rwannier(nwfc,tauref(:,:,:,ipx),rwann(:,:,ipx),swann(:,ipx),&
+                  vdwwfl%trwannc)
+             IF (.NOT.vdwwfl%trwannc) THEN
+                CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),1,&
+                     tauref(1,1,1,ipx),1)
+             ENDIF
+          ENDIF
+          CALL mp_bcast(tauref(:,:,:,ipx),3*maxsys%nax*maxsys%nsx,&
+               parai%io_source,parai%cp_grp)
+          CALL mp_bcast(rwann(:,:,ipx),3*nwfcx*nfragx,parai%io_source,parai%cp_grp)
+          CALL mp_bcast(swann(:,ipx),nwfcx*nfragx,parai%io_source,parai%cp_grp)
+          CALL mp_bcast(vdwwfl%trwannc,parai%io_source,parai%cp_grp)
+          trwanncx(ipx)=vdwwfl%trwannc
+       ENDIF
+       ! ..Initialization of wavefunction
+       IF (.NOT.restart1%restart) THEN
+          CALL rinitwf(c0(:,:,ipx:ipx),c2,sc0,crge%n,pitaup(:,:,:,ipcurr),taur,rhoe,psi)
+       ENDIF
        ! ..Initialize velocities
        IF (.NOT.restart1%rvel) THEN
           ener_com%ecnstr = 0.0_real_8
@@ -520,25 +635,29 @@
        ipx=ipcurr-np_low+1
        CALL phfac(pitaup(:,:,:,ipcurr))
        IF (corel%tinlc) CALL copot(rhoe,psi,ropt_mod%calste)
-       IF (pslo_com%tivan) THEN
-          DO ik=1,nkpt%nkpnt
-             CALL rnlsm(c0(:,ipx:ipx+crge%n-1,ik),crge%n,1,ik,.FALSE.)
-          ENDDO
-       ENDIF
-       IF (irec(irec_rho,ipcurr).EQ.0) THEN
-          ! ..Restore occupation numbers
-          CALL dcopy(crge%n*nkpt%nkpts,fall(1,ipx),1,crge%f,1)
-          IF (tkpts%tkpnt) THEN
-             CALL rhoofr_c(c0(:,:,ipx),rhoe,psi(:,1),crge%n)
+       ! Initialization of density and potential
+       ! for diagonalization schemes
+       IF (cntl%tdiag) THEN
+          IF (pslo_com%tivan) THEN
+             CALL rnlsm(c0(:,:,ipx),crge%n,1,1,.FALSE.)
+          ENDIF
+          IF (irec(irec_rho,ipcurr).EQ.0) THEN
+             ! ..Restore occupation numbers
+             IF (restart1%restart) THEN
+                CALL dcopy(crge%n*nkpt%nkpts,fall(1,ipx),1,crge%f,1)
+             ENDIF
+             IF (tkpts%tkpnt) THEN
+                CALL rhoofr_c(c0(:,:,ipx),rhoe,psi(:,1),crge%n)
+             ELSE
+                CALL rhoofr(c0(:,:,ipx),rhoe,psi(:,1),crge%n)
+             ENDIF
+             CALL dcopy(nnx,rhoe,1,rin0,1)
           ELSE
-             CALL rhoofr(c0(:,:,ipx),rhoe,psi(:,1),crge%n)
+             CALL dcopy(nnx,rall(1,ipx),1,rin0,1)
           ENDIF
-          CALL dcopy(nnx,rhoe,1,rin0,1)
-       ELSE
-          IF (cntl%tdiag) CALL dcopy(nnx,rall(1,ipx),1,rin0,1)
+          ! NON LOCAL PROJECTOR OVERLAP MATRIX
+          IF (fint1%ttrot) CALL calc_alm
        ENDIF
-       ! NON LOCAL PROJECTOR OVERLAP MATRIX
-       IF (fint1%ttrot) CALL calc_alm
        ! INITIALIZE WF CENTERS & SPREAD
        IF (vdwl%vdwd) THEN
           IF (.NOT.trwanncx(ipx)) THEN
@@ -545,11 +664,28 @@
              CALL localize2(pitaup(:,:,:,ipcurr),c0(:,:,ipx),c2,sc0,crge%n)
           ENDIF
        ENDIF
-       CALL forces_diag(crge%n,c0(:,:,ipx:),c2,cm,sc0,cm(nx),vpp,eigv(:,ipx),&
-            rhoe,psi,&
-            pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),&
-            pifion(:,:,:,ipcurr),&
-            ifcalc,irec(:,ipcurr),.TRUE.,.FALSE.)
+       n_inner_steps=0
+       n_large_steps=0
+       mts_large_step=.false.
+       if (cntl%use_mts) then
+          n_inner_steps=MOD(iteropt%nfi,mts%timestep_factor)
+          n_large_steps=iteropt%nfi/mts%timestep_factor
+          if (n_inner_steps==0) mts_large_step=.true.
+          call get_mts_forces(mts_large_step,.true.,n_inner_steps,n_large_steps,&
+             mts_pure_dft,fion_high,c0_high,coldall_high(:,:,:,:,ipx),&
+             nnowall_high(ipx),numcoldall_high(ipx),infi,&
+             crge%n,c0(:,:,ipx:),c2,cm,sc0,cm(nx),vpp,eigv(:,ipx),&
+             rhoe,psi,&
+             pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),&
+             pifion(:,:,:,ipcurr),&
+             ifcalc,irec(:,ipcurr),.true.,.true.)
+       else
+          CALL forces_diag(crge%n,c0(:,:,ipx:),c2,cm,sc0,cm(nx),vpp,eigv(:,ipx),&
+               rhoe,psi,&
+               pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),&
+               pifion(:,:,:,ipcurr),&
+               ifcalc,irec(:,ipcurr),.TRUE.,.TRUE.)
+       endif
        CALL dscal(3*maxsys%nax*maxsys%nsx,1._real_8/rnp,pifion(1,1,1,ipcurr),1)
        CALL dcopy(3*maxsys%nax*maxsys%nsx,pifion(1,1,1,ipcurr),1,&
             fionks(1,1,1,ipcurr),1)
@@ -577,9 +713,9 @@
           itemp=irec(irec_nop1,ipcurr)+irec(irec_nop2,ipcurr)+irec(irec_nop3,ipcurr)&
                +irec(irec_nop4,ipcurr)
           IF (cntl%tnosep .AND. itemp.EQ.0) CALL nospinit(ipcurr)
-          ! ..Centroid PICPMD: Set thermostat variables to zero in case 
+          ! ..Centroid & Ring-polymer PIMD: Set thermostat variables to zero in case 
           ! ..of a centroid restart from a non-centroid thermosatted run
-          IF (cntl%tnosep.AND.pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF (cntl%tnosep.AND.(pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              nrepl=maxnp
              IF (nosl%tultra) THEN
                 ! ..Not used with PICPMD 
@@ -587,14 +723,20 @@
                 CALL stopgm('PI_DIAG','LOCAL TEMPERATURE NOT IMPLEMENTET',& 
                      __LINE__,__FILE__)
              ELSEIF (nosl%tmnose) THEN
-                CALL stopgm(procedureN,'Massive NHCs thermostat not available for ip=1',&
-                     __LINE__,__FILE__)
-             !  DO k=1,3*maxsys%nax*maxsys%nsx
-             !     DO l=1,nchx
-             !        etapm(k,l,1)=0._real_8
-             !        etapmdot(k,l,1)=0._real_8
-             !     ENDDO
-             !  ENDDO
+                IF (pimd1%tcentro) THEN
+                   CALL stopgm(procedureN,'Massive NHCs thermostat not available for ip=1',&
+                        __LINE__,__FILE__)
+                ELSE
+                   ! ..Switch off if requested
+                   IF (.NOT.tnosepc) THEN
+                      DO k=1,3*maxsys%nax*maxsys%nsx
+                         DO l=1,nchx
+                            etapm(k,l,1)=0._real_8
+                            etapmdot(k,l,1)=0._real_8
+                         ENDDO
+                      ENDDO
+                   ENDIF
+                ENDIF
              ELSE
                 ! ..Switch off if requested
                 IF (.NOT.tnosepc) THEN
@@ -607,6 +749,27 @@
           ENDIF
        ENDDO
     ENDIF
+
+    ! Initialize GLE thermostat
+    iprng0=cnti%iprng
+    CALL repprngu_vec(npx,dummies)
+    DO ipcurr=np_low,np_high
+       ipx=ipcurr-np_low+1
+       CALL gleback(ipcurr,.FALSE.,1)
+       IF (.NOT.restart1%rprng.OR.irec(irec_prng,ipcurr).EQ.0) THEN
+          cnti%iprng=FLOOR(dummies(ipcurr)*iprng0)
+          IF (paral%io_parent) WRITE(6,*) 'USING SEED ', cnti%iprng,&
+             'TO REINIT. PSEUDO RANDOM NUMBER GEN.'
+          CALL prnginit
+       ENDIF
+       IF (pimd1%tstage.OR.pimd1%tpinm) THEN
+          CALL gle_init(stagep(:,:,:,ipcurr),vstage(:,:,:,ipcurr),pma0s(1,ipcurr))
+       ELSE
+          CALL gle_init(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),rmass%pma)
+       ENDIF
+       CALL gleback(ipcurr,.TRUE.,0)
+    ENDDO
+
     IF (grandparent) THEN
        IF (pimd3%levprt.GE.5) THEN
           DO ip=1,pimd3%np_total
@@ -637,6 +800,17 @@
     DO infi=1,cnti%nomore
        time1=m_walltime()
        iteropt%nfi=iteropt%nfi+1
+
+       ! MTS time step counters
+       n_inner_steps=n_inner_steps+1
+       mts_large_step=.false.
+       ! check if it is a large step
+       if (n_inner_steps==mts%timestep_factor) then
+          mts_large_step=.true.
+          n_large_steps=n_large_steps+1
+          n_inner_steps=0
+       endif
+
        ropt_mod%prteig=MOD(iteropt%nfi-1,cprint%iprint_step).EQ.0
        IF (.NOT.paral%parent) ropt_mod%prteig=.FALSE.
        ropt_mod%engpri=MOD(iteropt%nfi-1,cprint%iprint_step).EQ.0
@@ -646,26 +820,37 @@
        DO ipcurr=np_low,np_high
           ipx=ipcurr-np_low+1
           ! ANNEALING
-          IF (pimd1%tstage.OR.pimd1%tpinm) THEN
-             CALL anneal(vstage(:,:,:,ipcurr),c2,crge%n,scr)
-             CALL berendsen(vstage(:,:,:,ipcurr),c2,crge%n,scr,0.0_real_8,0.0_real_8)
-          ELSE
-             CALL anneal(pivelp(:,:,:,ipcurr),c2,crge%n,scr)
-             CALL berendsen(pivelp(:,:,:,ipcurr),c2,crge%n,scr,0.0_real_8,0.0_real_8)
-          ENDIF
-          ! ..UPDATE NOSE THERMOSTATS
-          nosl%tmnose=pitmnose(MIN(ipcurr,2))
-          IF (reset_gkt.AND.ipcurr==1) THEN
-             scr(1:2)=gkt(1:2,1); gkt(1:2,1)=gkt1(1:2,1)
-          ENDIF
-          IF (pimd1%tstage.OR.pimd1%tpinm) THEN
-             CALL noseup(vstage(:,:,:,ipcurr),c2,crge%n,ipcurr)
-          ELSE
-             CALL noseup(pivelp(:,:,:,ipcurr),c2,crge%n,ipcurr)
-          ENDIF
-          IF (reset_gkt.AND.ipcurr==1) gkt(1:2,1)=scr(1:2)
-          IF (pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          ! thermostats only if 1) standard dynamics 2) smaller MTS step
+          if ( .not.cntl%use_mts .or. .not.mts_large_step ) then
              IF (pimd1%tstage.OR.pimd1%tpinm) THEN
+                CALL anneal(vstage(:,:,:,ipcurr),c2,crge%n,scr)
+                CALL berendsen(vstage(:,:,:,ipcurr),c2,crge%n,scr,0.0_real_8,0.0_real_8)
+             ELSE
+                CALL anneal(pivelp(:,:,:,ipcurr),c2,crge%n,scr)
+                CALL berendsen(pivelp(:,:,:,ipcurr),c2,crge%n,scr,0.0_real_8,0.0_real_8)
+             ENDIF
+             ! ..UPDATE NOSE THERMOSTATS
+             nosl%tmnose=pitmnose(MIN(ipcurr,2))
+             IF (reset_gkt.AND.ipcurr==1) THEN
+                scr(1:2)=gkt(1:2,1); gkt(1:2,1)=gkt1(1:2,1)
+             ENDIF
+             IF (pimd1%tstage.OR.pimd1%tpinm) THEN
+                CALL noseup(vstage(:,:,:,ipcurr),c2,crge%n,ipcurr)
+             ELSE
+                CALL noseup(pivelp(:,:,:,ipcurr),c2,crge%n,ipcurr)
+             ENDIF
+             IF (reset_gkt.AND.ipcurr==1) gkt(1:2,1)=scr(1:2)
+             ! FIRST HALF OF GLE EVOLUTION
+             CALL gleback(ipcurr,.TRUE.,1)
+             IF (pimd1%tstage.OR.pimd1%tpinm) THEN
+                CALL gle_step(stagep(:,:,:,ipcurr),vstage(:,:,:,ipcurr),pma0s(1,ipcurr))
+             ELSE
+                CALL gle_step(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),rmass%pma)
+             ENDIF
+             CALL gleback(ipcurr,.TRUE.,0)
+          endif
+          IF ((pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
+             IF (pimd1%tstage.OR.pimd1%tpinm) THEN
                 ! SUBTRACT CENTER OF MASS VELOCITY
                 IF (paral%parent.AND.comvl%subcom) THEN
                    CALL comvel(vstage(:,:,:,1),vcmio,.TRUE.)
@@ -751,11 +936,22 @@
           IF (cntl%tdavi) nx=cnti%ndavv*nkpt%nkpnt+1
           ! ..CALCULATE THE FORCES
           ropt_mod%calste=cntl%tpres.AND.MOD(iteropt%nfi,cnti%npres).EQ.0
-          CALL forces_diag(crge%n,c0(:,:,ipx:),c2,cm,sc0,cm(nx),&
-               vpp,eigv(:,ipx),rhoe,psi,&
-               pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),taui(:,:,:,1),&
-               pifion(:,:,:,ipcurr),&
-               ifcalc,irec(:,ipcurr),.TRUE.,.FALSE.)
+          if (cntl%use_mts) then
+             call get_mts_forces(mts_large_step,.false.,n_inner_steps,n_large_steps,&
+                mts_pure_dft,fion_high,c0_high,coldall_high(:,:,:,:,ipx),&
+                nnowall_high(ipx),numcoldall_high(ipx),infi,&
+                crge%n,c0(:,:,ipx:),c2,cm,sc0,cm(nx),vpp,eigv(:,ipx),&
+                rhoe,psi,&
+                pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),&
+                pifion(:,:,:,ipcurr),&
+                ifcalc,irec(:,ipcurr),.true.,.false.)
+          else
+             CALL forces_diag(crge%n,c0(:,:,ipx:),c2,cm,sc0,cm(nx),&
+                  vpp,eigv(:,ipx),rhoe,psi,&
+                  pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),&
+                  pifion(:,:,:,ipcurr),&
+                  ifcalc,irec(:,ipcurr),.TRUE.,.FALSE.)
+          endif
           CALL dscal(3*maxsys%nax*maxsys%nsx,1._real_8/rnp,pifion(1,1,1,ipcurr),1)
           CALL dcopy(3*maxsys%nax*maxsys%nsx,pifion(1,1,1,ipcurr),1,&
                fionks(1,1,1,ipcurr),1)
@@ -844,7 +1040,7 @@
                 ENDIF
              ENDIF
           ENDIF
-          IF (pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF ((pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              IF (pimd1%tstage.OR.pimd1%tpinm) THEN
                 ! SUBTRACT ROTATION AROUND CENTER OF MASS
                 IF (paral%parent.AND.comvl%subrot) THEN
@@ -856,26 +1052,38 @@
                 ENDIF
              ENDIF
           ENDIF
-          ! ..UPDATE NOSE THERMOSTATS
-          nosl%tmnose=pitmnose(MIN(ipcurr,2))
-          IF (reset_gkt.AND.ipcurr==1) THEN
-             scr(1:2)=gkt(1:2,1); gkt(1:2,1)=gkt1(1:2,1)
-          ENDIF
-          IF (pimd1%tstage.OR.pimd1%tpinm) THEN
-             CALL noseup(vstage(:,:,:,ipcurr),c2,crge%n,ipcurr)
-          ELSE
-             CALL noseup(pivelp(:,:,:,ipcurr),c2,crge%n,ipcurr)
-          ENDIF
-          IF (reset_gkt.AND.ipcurr==1) gkt(1:2,1)=scr(1:2)
-          IF (pimd1%tpinm.OR.pimd1%tstage) THEN
-             CALL berendsen(vstage(:,:,:,ipcurr),c2,crge%n,scr,0.0_real_8,0.0_real_8)
-             ! ANNEALING
-             CALL anneal(vstage(:,:,:,ipcurr),c2,crge%n,scr)
-          ELSE
-             CALL berendsen(pivelp(:,:,:,ipcurr),c2,crge%n,scr,0.0_real_8,0.0_real_8)
-             ! ANNEALING
-             CALL anneal(pivelp(:,:,:,ipcurr),c2,crge%n,scr)
-          ENDIF
+          
+          ! thermostats only if 1) standard dynamics 2) smaller MTS step
+          if ( .not.cntl%use_mts .or. .not.mts_large_step ) then
+             ! SECOND HALF OF GLE EVOLUTION
+             CALL gleback(ipcurr,.TRUE.,1)
+             IF (pimd1%tstage.OR.pimd1%tpinm) THEN
+                 CALL gle_step(stagep(:,:,:,ipcurr),vstage(:,:,:,ipcurr),pma0s(1,ipcurr))
+             ELSE
+                 CALL gle_step(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),rmass%pma)
+             ENDIF
+             CALL gleback(ipcurr,.TRUE.,0)
+             ! ..UPDATE NOSE THERMOSTATS
+             nosl%tmnose=pitmnose(MIN(ipcurr,2))
+             IF (reset_gkt.AND.ipcurr==1) THEN
+                scr(1:2)=gkt(1:2,1); gkt(1:2,1)=gkt1(1:2,1)
+             ENDIF
+             IF (pimd1%tstage.OR.pimd1%tpinm) THEN
+                CALL noseup(vstage(:,:,:,ipcurr),c2,crge%n,ipcurr)
+             ELSE
+                CALL noseup(pivelp(:,:,:,ipcurr),c2,crge%n,ipcurr)
+             ENDIF
+             IF (reset_gkt.AND.ipcurr==1) gkt(1:2,1)=scr(1:2)
+             IF (pimd1%tpinm.OR.pimd1%tstage) THEN
+                CALL berendsen(vstage(:,:,:,ipcurr),c2,crge%n,scr,0.0_real_8,0.0_real_8)
+                ! ANNEALING
+                CALL anneal(vstage(:,:,:,ipcurr),c2,crge%n,scr)
+             ELSE
+                CALL berendsen(pivelp(:,:,:,ipcurr),c2,crge%n,scr,0.0_real_8,0.0_real_8)
+                ! ANNEALING
+                CALL anneal(pivelp(:,:,:,ipcurr),c2,crge%n,scr)
+             ENDIF
+          endif
           IF (paral%parent) THEN
              IF (pimd1%tpinm.OR.pimd1%tstage) THEN
                 CALL s_ekinpp(ekinp,vstage(:,:,:,ipcurr),ipcurr)
@@ -908,7 +1116,7 @@
              ! ..NOTE: ECNSTR IS ALWAYS ZERO
              econs(ipcurr)=ekinp+etotv(ipcurr)/rnp+&
                   enosp(ipcurr)+&
-                  eharv(ipcurr)+ener_com%ecnstr+ener_com%erestr
+                  eharv(ipcurr)+ener_com%ecnstr+ener_com%erestr+pi_egle(ipcurr)
           ENDIF
        ENDDO
        ! <<<<End of Replica Loop
@@ -930,6 +1138,7 @@
        CALL global(eham,1)
        CALL global(econs,1)
        CALL global(enosp,1)
+       CALL global(pi_egle,1)
        CALL global(disa,1)
        ! DM C..PRINTOUT the evolution of the accumulators every time step
        IF (grandparent) THEN
@@ -958,14 +1167,14 @@
              CALL prtgyr
              IF (paral%io_parent)&
                   WRITE(6,'(/,A,A)')&
-                  '    NFI   IP  TEMPP     EHARM         EKS',&
-                  '    ENOSE(P)    ECLASSIC     DIS'
+                  '      NFI   IP  TEMPP     EHARM         EKS',&
+                  '    ENOSE(P)      EGLE    ECLASSIC     DIS'
              DO ip=1,pimd3%np_total
                 IF (paral%io_parent)&
                      WRITE(6,&
-                     '(I7,I5,F7.1,F10.6,F12.5,2X,F10.5,F12.5, F8.2)')&
+                     '(I9,I5,F7.1,F10.6,F12.5,2X,F10.5,F10.5,F12.5, F8.2)')&
                      iteropt%nfi,ip,tempp(ip),eharv(ip),etotv(ip),&
-                     enosp(ip),econs(ip),disa(ip)
+                     enosp(ip),pi_egle(ip),econs(ip),disa(ip)
              ENDDO
           ENDIF
           ! ..Quantum kinetic energy of ions
@@ -994,13 +1203,13 @@
           tcpu=(time2-time1)*0.001_real_8
           IF ((ropt_mod%engpri).AND.paral%io_parent)&
                WRITE(6,'(/,A,A)')&
-               '    NFI   TEMP   EKINP(PRI)  EKINP(VIR)      EKS/P ',&
+               '      NFI   TEMP   EKINP(PRI)  EKINP(VIR)      EKS/P ',&
                '     EQUANT    ECLASSIC     TCPU'
           IF (paral%io_parent)&
-               WRITE(6,'(I7,F7.1,5F12.5,F9.2)')&
+               WRITE(6,'(I9,F7.1,5F12.5,F9.2)')&
                iteropt%nfi,tempa,qpkinp,qvkinp,etota,equant,econsa,tcpu
           IF (paral%io_parent)&
-               WRITE(3,'(I7,F7.1,5F20.10,F9.2)')&
+               WRITE(3,'(I9,F7.1,5F20.10,F9.2)')&
                iteropt%nfi,tempa,qpkinp,qvkinp,etota,equant,econsa,tcpu
           ! ..Store ionic coordinates and velocities for statistics
           ropt_mod%movie=rout1%mout .AND. MOD(iteropt%nfi-1,cnti%imovie).EQ.0
@@ -1020,7 +1229,7 @@
        IF (infi.EQ.cnti%nomore) soft_com%exsoft=.TRUE.
 
        nosl%tmnose=pitmnose(2)  ! recover original setup of tmnose
-       IF ((pimd1%tstage.OR.pimd1%tpinm).AND.nosl%tmnose) CALL wr_temps(iteropt%nfi,ekinc,tempp)
+       IF (pimd1%tstage.OR.pimd1%tpinm) CALL wr_temps(iteropt%nfi,ekinc,tempp)
        IF (ropt_mod%calste) THEN
           IF (pimd1%tstage.OR.pimd1%tpinm) THEN
              IF (cntl%tvirial) THEN
@@ -1064,6 +1273,7 @@
                      coldall(1,1,1,1,ipx),1,cold,1)
                 nnow=nnowall(ipx); numcold=numcoldall(ipx)
              ENDIF
+             CALL gleback(ipcurr,.FALSE.,1)
              nosl%tmnose=pitmnose(MIN(ipcurr,2))
              CALL write_irec(irec(:,ipcurr))
              CALL zhwwf(2,irec(:,ipcurr),c0(:,:,ipx),c2,crge%n,eigv(:,ipx),&
@@ -1157,6 +1367,49 @@
                __LINE__,__FILE__)
        ENDIF
     ENDIF
+    if (cntl%use_mts) then
+       deallocate(fion_high,stat=ierr)
+       if(ierr/=0) call stopgm(proceduren,'deallocation problem: fion_high',&
+          __LINE__,__FILE__)
+       if (mts_pure_dft) then
+          deallocate(c0_high,stat=ierr)
+          if(ierr/=0) call stopgm(proceduren,'deallocation problem: c0_high',&
+             __LINE__,__FILE__)
+          if (cntl%textrap) then
+             DEALLOCATE(coldall_high,STAT=ierr)
+             IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+                  __LINE__,__FILE__)
+             DEALLOCATE(nnowall_high,STAT=ierr)
+             IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+                  __LINE__,__FILE__)
+             DEALLOCATE(numcoldall_high,STAT=ierr)
+             IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+                  __LINE__,__FILE__)
+          end if
+       end if
+    end if
+    DEALLOCATE(pi_egle,STAT=ierr)
+    IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+         __LINE__,__FILE__)
+    IF (np_local>1) THEN
+       DEALLOCATE(pi_prng_com,STAT=ierr)
+       IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+            __LINE__,__FILE__)
+       IF (glepar%gle_mode>0) THEN
+          DEALLOCATE(pi_glec,STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+               __LINE__,__FILE__)
+          DEALLOCATE(pi_gles,STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+               __LINE__,__FILE__)
+          DEALLOCATE(pi_glet,STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+               __LINE__,__FILE__)
+          DEALLOCATE(pi_glep,STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+               __LINE__,__FILE__)
+       ENDIF
+    ENDIF
     IF (comvl%tsubrot) THEN
        DEALLOCATE(tauio,STAT=ierr)
        IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
@@ -1185,4 +1438,138 @@
   END SUBROUTINE pi_diag
   ! ==================================================================
 
+
+  ! Purpose: returns effective ionic forces in MTS algorithm
+  !      The forces are either from the low level or from a 
+  !      combination of high and low levels.
+  !
+  ! Author: Pablo Baudin
+  ! Date: May 2018
+  subroutine get_mts_forces(large_step,initialization,n_inner_steps, n_large_steps,&
+        mts_pure_dft,fion_high,c0_high,cold_high,nnow_high,numcold_high,infi,&
+        nstate,c0,c2,cr,csc0,cscr,vpp,eigv,&
+        rhoe,psi,tau0,velp,taui,fion,ifcalc,irec,tfor,tinfo)
+
+     implicit none
+
+     logical, intent(in) :: large_step, initialization, mts_pure_dft
+     integer, intent(inout) :: n_inner_steps
+     integer, intent(in) :: n_large_steps
+     logical :: tfor, tinfo
+     integer :: nnow_high, numcold_high
+     integer :: infi, nstate
+     integer :: ifcalc, irec(:)
+     real(real_8), allocatable :: fion_high(:,:,:)
+     real(real_8) :: vpp(ncpw%ngw), eigv(*), rhoe(:,:)
+     real(real_8) :: tau0(:,:,:), velp(:,:,:), taui(:,:,:), fion(:,:,:)
+     complex(real_8), allocatable :: c0_high(:,:,:)
+     complex(real_8) :: cold_high(:,:,:,:), c0(:,:,:), c2(nkpt%ngwk,nstate), cr(*)
+     complex(real_8) :: csc0(nkpt%ngwk,nstate), cscr(*)
+     complex(real_8) :: psi(:,:)
+
+     character(*), parameter :: proceduren = 'get_mts_forces'
+     character(len=100) :: title
+     integer :: i, ia, is, x, N
+
+
+     ! GET LOW LEVEL FORCES
+     if (paral%io_parent) write(6,'(1x,3a)') 'MTS: LOW LEVEL FORCES: ', &
+        mts%low_level, mts%low_dft_func
+     select case(mts%low_level)
+     case('EXTERNAL')
+        CALL stopgm(procedureN,'LOW_LEVEL_FORCES EXTERNAL not available',&
+           __LINE__,__FILE__)
+     !  call get_external_forces('EXT_LOW_FORCES', tau0, fion)
+
+     case('DFT')
+        if (initialization .and. mts_pure_dft) then
+           ! copy wf for extrapolation 
+           call dcopy(2*size(c0,1)*size(c0,2)*size(c0,3),c0,1,c0_high,1)
+        end if
+
+        call set_mts_functional('LOW')
+
+        call forces_diag(nstate,c0,c2,cr,csc0,cscr,vpp,eigv,&
+           rhoe,psi,tau0,velp,taui,fion,ifcalc,irec,tfor,tinfo)
+
+     case default
+        if(paral%io_parent) print *, 'Low level forces not available with', mts%low_level
+        call stopgm(proceduren,'wrong option for high level forces',&
+           __LINE__,__FILE__)
+
+     end select
+
+     ! print low level forces to file
+     if (mts%print_forces) then
+        write(title,'(1x,a,i10,10x,a,i10)') 'STEP:',iteropt%nfi,'N_INNER_STEPS:',n_inner_steps
+        call print_mts_forces(fion, title, 'LOW')
+     end if
+
+     if (large_step) then
+        ! GET HIGH LEVEL FORCES
+        if (paral%io_parent) write(6,'(1x,3a)') 'MTS: HIGH LEVEL FORCES: ', &
+           mts%high_level, mts%high_dft_func
+        select case(mts%high_level)
+        case('EXTERNAL')
+           CALL stopgm(procedureN,'HIGH_LEVEL_FORCES EXTERNAL not available',&
+              __LINE__,__FILE__)
+        !  call get_external_forces('EXT_HIGH_FORCES', tau0, fion_high)
+
+        case('DFT')
+
+           call set_mts_functional('HIGH')
+
+           if (mts_pure_dft) then
+
+              ! wf extrapolation
+              if (.not.initialization .and. cntl%textrap) then
+                 call extrapwf(infi,c0_high,cscr,cold_high,nnow_high,numcold_high,nstate,cnti%mextra)
+              end if
+
+              ! get forces
+              call forces_diag(nstate,c0_high,c2,cr,csc0,cscr,vpp,eigv,&
+                 rhoe,psi,tau0,velp,taui,fion_high,ifcalc,irec,tfor,tinfo)
+           else
+
+              ! In this case the wf extrap. is done in the main (outside) routine
+              call forces_diag(nstate,c0,c2,cr,csc0,cscr,vpp,eigv,&
+                 rhoe,psi,tau0,velp,taui,fion_high,ifcalc,irec,tfor,tinfo)
+           end if
+
+        case default
+           if(paral%io_parent) print *, 'High level forces not available with', mts%high_level
+           call stopgm(proceduren,'wrong option for high level forces',&
+              __LINE__,__FILE__)
+
+        end select
+
+        ! print high level forces to file
+        if (mts%print_forces) then
+           write(title,'(1x,a,i10,10x,a,i10)') 'STEP:',iteropt%nfi,'N_LARGE_STEPS:',n_large_steps
+           call print_mts_forces(fion_high, title, 'HIGH')
+        end if
+
+        ! get effective forces from difference between high and low level
+        !
+        !     F = F_low + (F_high - F_low) * N 
+        !     F = F_high * N - F_low * (N - 1)
+        !     
+        !     where N is the MTS time-step factor
+        ! 
+        N = mts%timestep_factor
+        do i=1,ions1%nat
+           ia=iatpt(1,i)
+           is=iatpt(2,i)
+           do x=1,3
+              fion(x,ia,is) = fion_high(x,ia,is) * N - fion(x,ia,is) * (N - 1)
+           end do
+        end do
+
+        ! reinitialize inner counter
+        n_inner_steps = 0
+
+     end if
+
+  end subroutine get_mts_forces
+
 END MODULE pi_diag_utils
Index: src/getgyr_utils.mod.F90
===================================================================
--- src/getgyr_utils.mod.F90	(revision 4634)
+++ src/getgyr_utils.mod.F90	(revision 4635)
@@ -1,6 +1,7 @@
 MODULE getgyr_utils
   USE cnst,                            ONLY: factem
   USE ekinpp_utils,                    ONLY: ekinpp
+  USE glemod,                          ONLY: glepar
   USE ions,                            ONLY: ions0,&
                                              ions1
   USE kinds,                           ONLY: real_8
@@ -47,7 +48,7 @@
     ! If we're doing PI with NVE we need to use the instantaneous
     ! temperature here. For details, see:
     ! http://cpmd.org/mailman/htdig/cpmd-list/2008-April/004350.html
-    IF (cntl%tnosep) THEN
+    IF (cntl%tnosep.OR.glepar%gle_mode>0) THEN
        tempp1=cntr%tempw
     ELSE
        CALL ekinpp(ekinp1,velp(:,:,:,1))
Index: src/mdmain_utils.mod.F90
===================================================================
--- src/mdmain_utils.mod.F90	(revision 4634)
+++ src/mdmain_utils.mod.F90	(revision 4635)
@@ -127,6 +127,7 @@
                                              rhopri
   USE rinvel_utils,                    ONLY: rinvel,&
                                              rvscal
+  USE rmas,                            ONLY: rmass
   USE ropt,                            ONLY: infi,&
                                              iteropt,&
                                              ropt_mod
@@ -625,7 +626,7 @@
     ENDIF
 
     ! INITIALIZE GLE
-    CALL gle_init
+    CALL gle_init(tau0,velp,rmass%pma)
 
     IF (paral%parent) THEN
        IF (paral%io_parent)&
@@ -698,7 +699,7 @@
        bsclcs=1
        CALL noseup(velp,cm,nstate,ipwalk)
        ! FIRST HALF OF GLE EVOLUTION
-       IF (glepar%gle_mode.GT.0) CALL gle_step()
+       IF (glepar%gle_mode.GT.0) CALL gle_step(tau0,velp,rmass%pma)
 
        ! -FOR HIGH SPIN 
        IF (cntl%bsymm)THEN
@@ -958,7 +959,7 @@
        ENDIF
 #endif
        ! SECOND HALF OF GLE EVOLUTION
-       IF (glepar%gle_mode.GT.0) CALL gle_step
+       IF (glepar%gle_mode.GT.0) CALL gle_step(tau0,velp,rmass%pma)
 
        ! UPDATE NOSE THERMOSTATS
        IF (cntl%tnosee.OR.cntl%tc) THEN
Index: src/nabdy_md.mod.F90
===================================================================
--- src/nabdy_md.mod.F90	(revision 4634)
+++ src/nabdy_md.mod.F90	(revision 4635)
@@ -525,7 +525,7 @@
     ENDIF
 
     ! INITIALIZE GLE THERMO
-    CALL gle_init
+    CALL gle_init(tau0,velp,rmass%pma)
 
     CALL write_irec(irec)
     ! ==--------------------------------------------------------------==
@@ -598,7 +598,7 @@
           ! UPDATE NOSE THERMOSTATS
           CALL noseup(velp,c2,nstate,1)
           ! FIRST HALF OF GLE EVOLUTION
-          CALL gle_step
+          CALL gle_step(tau0,velp,rmass%pma)
 
           ! SUBTRACT CENTER OF MASS VELOCITY
           IF (paral%io_parent.AND.comvl%subcom) CALL comvel(velp,vcmio,.TRUE.)
@@ -745,7 +745,7 @@
           IF (paral%io_parent.AND.comvl%subcom) CALL comvel(velp,vcmio,.FALSE.)
 
           ! SECOND HALF OF GLE EVOLUTION
-          CALL gle_step
+          CALL gle_step(tau0,velp,rmass%pma)
 
           ! UPDATE NOSE THERMOSTATS
           CALL noseup(velp,c2,nstate,1)
Index: src/pi_cntl_utils.mod.F90
===================================================================
--- src/pi_cntl_utils.mod.F90	(revision 4634)
+++ src/pi_cntl_utils.mod.F90	(revision 4635)
@@ -2,6 +2,7 @@
   USE cotr,                            ONLY: cotc0,&
                                              lskcor
   USE error_handling,                  ONLY: stopgm
+  USE glemod,                          ONLY: glepar
   USE inscan_utils,                    ONLY: inscan
   USE ions,                            ONLY: ions1
   USE kinds,                           ONLY: real_8
@@ -46,6 +47,7 @@
     ! ==    TROTTER DIMENSION                                         ==
     ! ==      np_total                                                ==
     ! ==    CENTROID DYNAMICS                                         ==
+    ! ==    RING-POLYMER DYNAMICS                                     ==
     ! ==    CLASSICAL TEST                                            == 
     ! ==    STAGING                                                   ==
     ! ==      facstage                                                ==
@@ -64,6 +66,8 @@
     ! ==    OUTPUT [ALL,GROUPS,PARENT]                                ==
     ! ==    PRINT LEVEL                                               ==
     ! ==       levprt                                                 ==
+    ! ==    GLE_LAMBDA                                                ==
+    ! ==       gle_lambda                                             ==
     ! ==--------------------------------------------------------------==
     ! Variables
     CHARACTER(*), PARAMETER                  :: procedureN = 'pi_cntl'
@@ -94,11 +98,13 @@
        pimd1%tpinm = .FALSE.
        pimd1%tinit = .FALSE.
        pimd1%tcentro = .FALSE.
+       pimd1%tringp = .FALSE.
        pimd1%testpi = .FALSE.
        pimd3%np_total  =  1
        pimd2%tempb  =  500._real_8
        pimd2%wmass  =  1._real_8
        pimd2%facstage = 1._real_8
+       pimd2%gle_lambda = 0.5_real_8
        pc_groups = 0
        repfname = ' '
        pimd3%levprt = 0
@@ -131,11 +137,14 @@
                    something_went_wrong = .TRUE.
                    go_on_reading        = .FALSE.
                 ENDIF
-             ELSEIF ( keyword_contains(line,'CENTROID',and='DYNAMICS') ) THEN
+             ELSEIF ( keyword_contains(line,'CENTROID',and='DYNAMICS',alias='CMD') ) THEN
                 ! do centroid path integral cntl%md and
                 ! DM C do centroid path integral cntl%md (only together with normal modes) and
                 ! do not thermostat centroid mode, i.e., first Trotter slice
                 pimd1%tcentro=.TRUE.
+             ELSEIF ( keyword_contains(line,'RING-POLYMER',and='DYNAMICS',alias='RPMD') ) THEN
+                ! do ring-polymer path integral md 
+                pimd1%tringp=.TRUE.
              ELSEIF ( keyword_contains(line,'CLASSICAL',and='TEST') ) THEN
                 pimd1%testpi=.TRUE.
              ELSEIF ( keyword_contains(line,'STAGING') ) THEN
@@ -258,6 +267,13 @@
                 IF ( keyword_contains(line,'PARENT') ) pimd3%loutfn=0
                 IF ( keyword_contains(line,'GROUPS',alias='GROUP') ) pimd3%loutfn=1
                 IF ( keyword_contains(line,'ALL') ) pimd3%loutfn=2
+             ELSEIF ( keyword_contains(line,'GLE_LAMBDA') ) THEN
+                READ(iunit,*,iostat=ierr) pimd2%gle_lambda
+                IF (ierr /= 0) THEN
+                   error_message        = 'ERROR WHILE READING LINE'
+                   something_went_wrong = .TRUE.
+                   go_on_reading        = .FALSE.
+                ENDIF
              ELSE
                 ! Dummy line
                 IF (' ' /= line) THEN
@@ -340,8 +356,8 @@
           ENDIF
        ENDIF
        IF (cntl%md) THEN
-          pimd1%rrep=.FALSE.
-          pimd1%repread=.FALSE.
+       !  pimd1%rrep=.FALSE.
+       !  pimd1%repread=.FALSE.
           IF (cntr%tempw.LE.1.0e-5_real_8) CALL stopgm(procedureN,&
                'PIMD: You have to set temperature or use a thermostat',& 
                __LINE__,__FILE__)
@@ -348,9 +364,9 @@
           IF ((cntl%trane).AND.paral%io_parent) CALL stopgm(procedureN,&
                'RANDOMIZE WAVEFUNCTIONS not implemented with PIMD.',&
                __LINE__,__FILE__)
-          IF (cntl%quenchb) CALL stopgm(procedureN,&
-               'QUENCH BO  not implemented with PIMD.',& 
-               __LINE__,__FILE__)
+       !  IF (cntl%quenchb) CALL stopgm(procedureN,&
+       !       'QUENCH BO  not implemented with PIMD.',& 
+       !       __LINE__,__FILE__)
           ! check selected number of pc_groups not negative 
           IF (pc_groups < 0) CALL stopgm(procedureN,'Negative number for PI PC_GROUPS',&
                __LINE__,__FILE__)
@@ -362,6 +378,11 @@
                 'NPT PIMD needs staging or normal mode representation',&
                 __LINE__,__FILE__)
           ENDIF
+          IF (.NOT.restart1%restart) THEN
+             pimd1%tinit=.TRUE.
+             IF (.NOT.cntl%tmdbo) cntl%quenchb=.TRUE.
+             IF (.NOT.(pimd1%rrep.OR.pimd1%repread)) pimd1%rrep=.TRUE.
+          ENDIF
        ELSEIF (cntl%wfopt) THEN
           pc_groups = 1
           IF (.NOT.restart1%restart) THEN
@@ -399,6 +420,14 @@
                 ' WARNING: FACSTAGE SHOULD BE UNITY, PLEASE VERIFY YOUR INPUT'
        ENDIF
        ! DM2
+       IF (pimd1%tringp) THEN
+          IF (pimd1%tstage) CALL stopgm(procedureN,&
+             'STAGING representation not yet supported for RING-POLYMER DYNAMICS',&
+             __LINE__,__FILE__)
+       ENDIF
+       IF (pimd2%gle_lambda < 0.0_real_8) CALL stopgm(procedureN,&
+          'Negative GLE_LAMBDA not acceptable',&
+          __LINE__,__FILE__)
 
     END SUBROUTINE check_options
     ! ==--------------------------------------------------------------==
@@ -426,6 +455,10 @@
           IF (pimd1%tstage) WRITE(output_unit,'(A)')&
                ' YIELDING THE WIGNER DISTRIBUTION'
        ENDIF
+       IF (pimd1%tringp) THEN
+          WRITE(output_unit,'(A)')&
+               ' QUASICLASSICAL RING-POLYMER DYNAMICS'
+       ENDIF
        ! DM2
        WRITE(output_unit,'(A,7x,I4)') ' TROTTER DIMENSION:',pimd3%np_total
        IF (pimd1%tinit) WRITE(output_unit,'(A)') ' INITIALIZATION RUN'
@@ -458,12 +491,15 @@
           WRITE(output_unit,'(A)') ' USE PRIMITIVE VARIABLES '
        ENDIF
        ! DM2
-       IF (pimd1%tpinm .OR. pimd1%tstage) THEN
+       IF ((pimd1%tpinm .OR. pimd1%tstage).AND.(.NOT.pimd1%tringp)) THEN
           ! DM        WRITE(output_unit,'(A,G12.6)') ' >>>> FACMASS : ',WMASS
           WRITE(output_unit,'(A,4x,G12.6)') ' SCALING FACTOR FACMASS:',pimd2%wmass
           ! DM        WRITE(output_unit,'(A,G12.6)') ' >>>> FACSTAGE: ',FACSTAGE
           WRITE(output_unit,'(A,3x,G12.6)') ' MASS DISPARITY FACSTAGE:',pimd2%facstage
        ENDIF
+       IF (glepar%gle_mode>0) THEN
+          WRITE(output_unit,'(A,2x,G12.6)') ' SCALING FACTOR GLE_LAMBDA:',pimd2%gle_lambda
+       ENDIF
        WRITE(output_unit,'(A,13x,I4)') ' PRINT LEVEL:',pimd3%levprt
 
     END SUBROUTINE pi_cntl_report
Index: src/rinvel_utils.mod.F90
===================================================================
--- src/rinvel_utils.mod.F90	(revision 4634)
+++ src/rinvel_utils.mod.F90	(revision 4635)
@@ -17,7 +17,9 @@
                                              tempwr
   USE parac,                           ONLY: parai,&
                                              paral
-  USE pimd,                            ONLY: pma0s
+  USE pimd,                            ONLY: pma0s,&
+                                             pimd1,&
+                                             ipcurr
   USE prng_utils,                      ONLY: repprngu,&
                                              repprngu_vec
   USE puttau_utils,                    ONLY: taucl
@@ -328,7 +330,11 @@
     IF (paral%parent) THEN
        ! RESCALE VELOCITIES
        IF (.NOT.tcafes) THEN
-          CALL ekinpp(ekinp,vel)
+          IF (cntl%tpath.AND.cntl%tpimd.AND.(pimd1%tpinm.OR.pimd1%tstage)) THEN
+             CALL s_ekinpp(ekinp,vel,ipcurr)
+          ELSE
+             CALL ekinpp(ekinp,vel)
+          ENDIF
           tempp=ekinp*factem*2._real_8/glib
           IF (paral%io_parent)&
                WRITE(6,'(A,F13.5,A,F13.5)') ' RVSCAL| RESCALING IONIC '&
Index: src/pi_wf_utils.mod.F90
===================================================================
--- src/pi_wf_utils.mod.F90	(revision 4634)
+++ src/pi_wf_utils.mod.F90	(revision 4635)
@@ -3,7 +3,10 @@
   USE error_handling,                  ONLY: stopgm
   USE filnmod,                         ONLY: filbod,&
                                              filn
-  USE parac,                           ONLY: paral
+  USE kinds,                           ONLY: real_8
+  USE mp_interface,                    ONLY: mp_bcast
+  USE parac,                           ONLY: paral,&
+                                             parai
   USE pimd,                            ONLY: ipcurr,&
                                              np_high,&
                                              np_low,&
@@ -26,6 +29,7 @@
   PRIVATE
 
   PUBLIC :: pi_wf
+  PUBLIC :: initrep
 
 CONTAINS
 
@@ -106,5 +110,56 @@
     CALL tihalt(procedureN,isub)
   END SUBROUTINE pi_wf
   ! ==================================================================
+  SUBROUTINE initrep(pitaup)
+    ! ==--------------------------------------------------------------==
+    ! == initialize replica coordinates in the initialization process ==
+    ! == of path integral MD runs                                     ==
+    ! ==--------------------------------------------------------------==
+    ! Variables
+    REAL(real_8)                             :: pitaup(:,:,:,:)
+    CHARACTER(*), PARAMETER                  :: procedureN = 'initrep'
+    INTEGER                                  :: ierr
+    ! ==--------------------------------------------------------------==
+    ! ..Generate Replica coordinates
+    ALLOCATE(trep(3,maxsys%nax,maxsys%nsx,pimd3%np_total),STAT=ierr)
+    IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+         __LINE__,__FILE__)
+    IF (pimd1%tread_cent.OR.pimd1%tpinm) THEN
+       ALLOCATE(trepnm(3,maxsys%nax,maxsys%nsx,pimd3%np_total),STAT=ierr)
+       IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+            __LINE__,__FILE__)
+    ENDIF
+    IF (pimd1%rrep) THEN
+       CALL repgen(tau0)
+       ! DM1
+       ! ..Classical test
+       IF (pimd1%testpi) THEN
+          CALL dcopy(3*maxsys%nax*maxsys%nsx,tau0,1,trep(1,1,1,1),1)
+       ENDIF
+       ! DM2
+    ELSEIF (pimd1%repread) THEN
+       CALL rreadf
+    ENDIF
+    ! ..Copy trep to pitaup and broadcast in cp_grp 
+    DO ipcurr=np_low,np_high
+       IF (paral%io_parent) THEN
+          CALL dcopy(3*maxsys%nax*maxsys%nsx,trep(1,1,1,ipcurr),1,&
+             pitaup(1,1,1,ipcurr),1)
+       ENDIF
+       CALL mp_bcast(pitaup(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,&
+          parai%io_source,parai%cp_grp)
+    ENDDO
+    DEALLOCATE(trep,STAT=ierr)
+    IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+         __LINE__,__FILE__)
+    IF (pimd1%tread_cent.OR.pimd1%tpinm) THEN
+       DEALLOCATE(trepnm,STAT=ierr)
+       IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+            __LINE__,__FILE__)
+    ENDIF
+    ! ==--------------------------------------------------------------==
+    RETURN
+  END SUBROUTINE initrep
+  ! ==================================================================
 
 END MODULE pi_wf_utils
Index: src/gle_utils.mod.F90
===================================================================
--- src/gle_utils.mod.F90	(revision 4634)
+++ src/gle_utils.mod.F90	(revision 4635)
@@ -1,7 +1,5 @@
 MODULE gle_utils
   USE cnst,                            ONLY: factem
-  USE coor,                            ONLY: tau0,&
-                                             velp
   USE cotr,                            ONLY: lskcor
   USE error_handling,                  ONLY: stopgm
   USE glemod,                          ONLY: &
@@ -11,13 +9,17 @@
   USE isos,                            ONLY: isos1
   USE kinds,                           ONLY: int_4,&
                                              real_8
+  USE meta_multiple_walkers_utils,     ONLY: mw_filename
   USE mp_interface,                    ONLY: mp_bcast
   USE parac,                           ONLY: parai,&
                                              paral
+  USE pimd,                            ONLY: pimd1,&
+                                             ipcurr,&
+                                             pi_omega
   USE prng_utils,                      ONLY: repprngg
-  USE rmas,                            ONLY: rmass
   USE store_types,                     ONLY: restart1
   USE system,                          ONLY: cntr,&
+                                             cntl,&
                                              maxsys
   USE zeroing_utils,                   ONLY: zeroing
 
@@ -31,10 +33,12 @@
 
 CONTAINS
 
-  SUBROUTINE gle_init()
+  SUBROUTINE gle_init(tau0,velp,pmx)
 
+    REAL(real_8)                             :: tau0(:,:,:), velp(:,:,:), pmx(*)
     INTEGER                                  :: i, ia, id, iostat, is, msglen
     INTEGER(int_4)                           :: gleok
+    CHARACTER(len=80)                        :: filen
     REAL(real_8) :: lglea(glepar%gle_ns+1,glepar%gle_ns+1), &
       lglec(glepar%gle_ns+1,glepar%gle_ns+1), &
       lgles(glepar%gle_ns+1,glepar%gle_ns+1), &
@@ -55,12 +59,16 @@
     ! initializes friction matrix, using presets or custom file
     gleok = 0
     IF (glepar%gle_mode .EQ. gle_white) THEN
+       IF (cntl%tpath.AND.cntl%tpimd) glepar%gle_omega=pi_omega(ipcurr)
        lglea(1,1)=glepar%gle_omega*icm2au
     ELSEIF (glepar%gle_mode .EQ. gle_opt) THEN
+       IF (cntl%tpath.AND.cntl%tpimd) glepar%gle_omega=pi_omega(ipcurr)
        lglea=gle_opt_a*glepar%gle_omega*0.01_real_8*icm2au
     ELSEIF (glepar%gle_mode .EQ. gle_cpmd) THEN
+       IF (cntl%tpath.AND.cntl%tpimd) glepar%gle_omega=pi_omega(ipcurr)
        lglea=gle_cp_a*glepar%gle_omega*icm2au
     ELSEIF (glepar%gle_mode .EQ. gle_smart) THEN
+       IF (cntl%tpath.AND.cntl%tpimd) glepar%gle_omega=pi_omega(ipcurr)
        lglea=gle_smart_a*glepar%gle_omega*icm2au     
     ELSEIF (glepar%gle_mode .EQ. gle_cust) THEN 
        ! reads custom parameters on root & broadcasts 
@@ -67,7 +75,12 @@
        IF (paral%parent) THEN
           ! the A matrix is read from GLE-A file
           IF (paral%io_parent) THEN
-             OPEN(444,file="GLE-A",status="OLD",iostat=iostat)
+             IF (cntl%tpath.AND.cntl%tpimd) THEN
+                CALL mw_filename("GLE-A",filen,ipcurr)
+                OPEN(444,file=filen,status="OLD",iostat=iostat)
+             ELSE
+                OPEN(444,file="GLE-A",status="OLD",iostat=iostat)
+             ENDIF
              IF (iostat==0) THEN
                 DO i=1,glepar%gle_ns+1              
                    READ(444,*) lglea(i,:)
@@ -77,7 +90,12 @@
                 gleok=1
              ENDIF
              ! the C matrix is read from GLE-C file, if it exists
-             OPEN(444,file="GLE-C",status="OLD",iostat=iostat)
+             IF (cntl%tpath.AND.cntl%tpimd) THEN
+                CALL mw_filename("GLE-C",filen,ipcurr)
+                OPEN(444,file=filen,status="OLD",iostat=iostat)
+             ELSE
+                OPEN(444,file="GLE-C",status="OLD",iostat=iostat)
+             ENDIF
              IF (iostat==0) THEN
                 DO i=1,glepar%gle_ns+1
                    READ(444,*) lglec(i,:)
@@ -132,7 +150,7 @@
           IF (lglec(1,1).NE.0.0_real_8) THEN
              CALL scholesky(lglec,ltmp,glepar%gle_ns+1)! used for initialization of velocities
              DO is=1,maxsys%nsx
-                sqrtm=SQRT(rmass%pma(is))
+                sqrtm=SQRT(pmx(is))
                 DO ia=1,ions0%na(is)
                    DO id=1,3
                       DO i=1,glepar%gle_ns+1
@@ -148,14 +166,14 @@
           ELSE
              CALL zeroing(glep)!,maxsys%nsx*maxsys%nax*3*(glepar%gle_ns+1))
           ENDIF
-          IF (glepar%gle_com.GT.0) CALL gle_rmcom()
-          IF (glepar%gle_com.GT.0 .AND. isos1%tisos) CALL gle_rmrot(tau0)
+          IF (glepar%gle_com.GT.0) CALL gle_rmcom(pmx)
+          IF (glepar%gle_com.GT.0 .AND. isos1%tisos) CALL gle_rmrot(tau0,pmx)
        ENDIF
 
        ! if not restarting velocities, initializes them
        IF (.NOT. restart1%rvel) THEN
           DO is=1,maxsys%nsx
-             sqrtm=SQRT(rmass%pma(is))
+             sqrtm=SQRT(pmx(is))
              DO ia=1,ions0%na(is)
                 velp(:,ia,is)=glep(:,ia,is,1)/sqrtm
              ENDDO
@@ -174,8 +192,9 @@
     CALL dcopy((glepar%gle_ns+1)*(glepar%gle_ns+1),lglet,1,glet,1)
   END SUBROUTINE gle_init
 
-  SUBROUTINE gle_step
+  SUBROUTINE gle_step(tau0,velp,pmx)
 
+    REAL(real_8)                             :: tau0(:,:,:), velp(:,:,:), pmx(*)
     INTEGER                                  :: i, ia, iat, id, is, l
     REAL(real_8) :: degle, lgles(glepar%gle_ns+1,glepar%gle_ns+1), &
       lglet(glepar%gle_ns+1,glepar%gle_ns+1), rv(glepar%gle_ns+1), sqrtm, &
@@ -190,7 +209,7 @@
     degle=0
     iat = 0
     DO is=1,maxsys%nsx
-       sqrtm=SQRT(rmass%pma(is))
+       sqrtm=SQRT(pmx(is))
        DO ia=1,ions0%na(is)
           iat = iat+1
           DO l=1,3
@@ -233,12 +252,12 @@
     ENDDO
 
     ! removes COM velocity
-    IF (glepar%gle_com.GT.0) CALL gle_rmcom()
-    IF (glepar%gle_com.GT.0 .AND. isos1%tisos) CALL gle_rmrot(tau0)
+    IF (glepar%gle_com.GT.0) CALL gle_rmcom(pmx)
+    IF (glepar%gle_com.GT.0 .AND. isos1%tisos) CALL gle_rmrot(tau0,pmx)
     ! scale back velocities & updates Dconserved      
     iat = 0
     DO is=1,maxsys%nsx
-       sqrtm=SQRT(rmass%pma(is))
+       sqrtm=SQRT(pmx(is))
        DO ia=1,ions0%na(is) 
           iat = iat+1
           DO l=1,3   ! skips coordinates that are fixed
@@ -278,8 +297,9 @@
          __LINE__,__FILE__)
   END SUBROUTINE gle_alloc
 
-  SUBROUTINE gle_rmcom()
+  SUBROUTINE gle_rmcom(pmx)
 
+    REAL(real_8)                             :: pmx(*)
     INTEGER                                  :: i, ia, is
     REAL(real_8)                             :: com(3), mm, sqrtm
 
@@ -287,8 +307,8 @@
        com=0.0_real_8
        mm=0.0_real_8
        DO is=1,maxsys%nsx
-          sqrtm=SQRT(rmass%pma(is))
-          mm=mm+rmass%pma(is)*ions0%na(is)
+          sqrtm=SQRT(pmx(is))
+          mm=mm+pmx(is)*ions0%na(is)
           DO ia=1,ions0%na(is)
              com(:)=com(:)+glep(:,ia,is,i)*sqrtm
           ENDDO
@@ -295,7 +315,7 @@
        ENDDO
        com=com/mm! COM velocity
        DO is=1,maxsys%nsx
-          sqrtm=SQRT(rmass%pma(is))
+          sqrtm=SQRT(pmx(is))
           DO ia=1,ions0%na(is)
              glep(:,ia,is,i)=glep(:,ia,is,i)-com(:)*sqrtm
           ENDDO
@@ -304,9 +324,9 @@
   END SUBROUTINE gle_rmcom
 
   ! removes rotational velocities, to additional momenta as well. assumes no COM velocity is present
-  SUBROUTINE gle_rmrot(tau0)
+  SUBROUTINE gle_rmrot(tau0,pmx)
 
-    REAL(real_8)                             :: tau0(:,:,:)
+    REAL(real_8)                             :: tau0(:,:,:), pmx(*)
 
     INTEGER                                  :: i, ia, info, ipiv(3), is, j, &
                                                 work(9)
@@ -318,9 +338,9 @@
     com=0.0_real_8
     tm=0.0_real_8
     DO is=1,maxsys%nsx
-       tm=tm+ions0%na(is)*rmass%pma(is)
+       tm=tm+ions0%na(is)*pmx(is)
        DO ia=1,ions0%na(is)
-          com=com+taum(:,ia,is)*rmass%pma(is)
+          com=com+taum(:,ia,is)*pmx(is)
        ENDDO
     ENDDO
     com=com*(1./tm)
@@ -333,9 +353,9 @@
        DO ia=1,ions0%na(is)
           rm=(taum(1,ia,is)**2+taum(2,ia,is)**2+taum(3,ia,is)**2)
           DO i=1,3
-             im(i,i)=im(i,i)+rmass%pma(is)*(rm-taum(i,ia,is)**2)
+             im(i,i)=im(i,i)+pmx(is)*(rm-taum(i,ia,is)**2)
              DO j=i+1,3
-                im(i,j)=im(i,j)-rmass%pma(is)*taum(i,ia,is)*taum(j,ia,is)
+                im(i,j)=im(i,j)-pmx(is)*taum(i,ia,is)*taum(j,ia,is)
                 im(j,i)=im(i,j)
              ENDDO
           ENDDO
@@ -350,7 +370,7 @@
        ! get angular momentum
        lm=0.0_real_8
        DO is=1,maxsys%nsx
-          rm=SQRT(rmass%pma(is))
+          rm=SQRT(pmx(is))
           DO ia=1,ions0%na(is)
              lm(1)=lm(1)+rm*&
                   (taum(2,ia,is)*glep(3,ia,is,i)-&
@@ -365,7 +385,7 @@
        ENDDO
        wm=MATMUL(im1,lm)! angular velocity
        DO is=1,maxsys%nsx
-          rm=SQRT(rmass%pma(is))
+          rm=SQRT(pmx(is))
           DO ia=1,ions0%na(is)
              ! gets velocity
              lm(1)=(wm(2)*taum(3,ia,is)-wm(3)*taum(2,ia,is))
Index: src/control_def_utils.mod.F90
===================================================================
--- src/control_def_utils.mod.F90	(revision 4634)
+++ src/control_def_utils.mod.F90	(revision 4635)
@@ -21,7 +21,8 @@
   USE g_loc,                           ONLY: glocal,&
                                              gloci,&
                                              glocr
-  USE glemod,                          ONLY: glepar
+  USE glemod,                          ONLY: glepar,&
+                                             tglepc
   USE ions,                            ONLY: coord_fdiff,&
                                              r_fdiff,&
                                              tref_fdiff
@@ -146,6 +147,7 @@
     glepar%gle_omega=0.0_real_8
     glepar%gle_ns=0
     glepar%gle_com=1
+    tglepc=.TRUE. 
     cnti%iprng=123456
     czones(1,1)=10.0_real_8
     czones(1,2)=1.0e-3_real_8 ! outmost zone sloppy convergence
Index: src/prng.mod.F90
===================================================================
--- src/prng.mod.F90	(revision 4634)
+++ src/prng.mod.F90	(revision 4635)
@@ -8,5 +8,6 @@
      REAL(real_8) :: paraseed(2,3)  = 0.0_real_8
   END TYPE prng_com_t
   TYPE(prng_com_t), SAVE :: prng_com
+  TYPE(prng_com_t), SAVE, ALLOCATABLE :: pi_prng_com(:)
 
 END MODULE prng
Index: src/nospinit_utils.mod.F90
===================================================================
--- src/nospinit_utils.mod.F90	(revision 4634)
+++ src/nospinit_utils.mod.F90	(revision 4635)
@@ -37,7 +37,7 @@
 ! ==--------------------------------------------------------------==
 
     IF (cntl%tpath.AND.cntl%tpimd) THEN
-       IF (pimd1%tcentro.AND.ip.EQ.1.AND..NOT.tnosepc) RETURN
+       IF ((pimd1%tcentro.OR.pimd1%tringp).AND.ip.EQ.1.AND..NOT.tnosepc) RETURN
     ENDIF
     ipp=1
     IF (cntl%tpath.AND.cntl%tpimd) ipp=MIN(ip,2)
Index: src/noseup_utils.mod.F90
===================================================================
--- src/noseup_utils.mod.F90	(revision 4634)
+++ src/noseup_utils.mod.F90	(revision 4635)
@@ -72,7 +72,7 @@
        DO i=1,nit
           DO j=1,ncalls
              IF (cntl%tpath.AND.cntl%tpimd) THEN
-                IF (.NOT.(pimd1%tcentro.AND.ip.EQ.1.AND..NOT.tnosepc)) THEN
+                IF (.NOT.((pimd1%tcentro.OR.pimd1%tringp).AND.ip.EQ.1.AND..NOT.tnosepc)) THEN
                    IF (pimd1%tpinm.OR.pimd1%tstage) THEN
                       CALL pnosmove(velp,dtsuz(j),pma0s(1,ip),ip)
                    ELSE
Index: src/nosepa_utils.mod.F90
===================================================================
--- src/nosepa_utils.mod.F90	(revision 4634)
+++ src/nosepa_utils.mod.F90	(revision 4635)
@@ -1,5 +1,6 @@
 MODULE nosepa_utils
-  USE cnst,                            ONLY: factem
+  USE cnst,                            ONLY: factem,&
+                                             pi
   USE cotr,                            ONLY: cotc0,&
                                              lskcor,&
                                              ntcnst
@@ -27,7 +28,9 @@
   USE parac,                           ONLY: paral
   USE pimd,                            ONLY: grandparent,&
                                              pimd1,&
-                                             pimd3
+                                             pimd2,&
+                                             pimd3,&
+                                             flnm
   USE prcp,                            ONLY: prcpl
   USE system,                          ONLY: cnti,&
                                              cntl,&
@@ -60,7 +63,7 @@
     ! ==--------------------------------------------------------------==
     INTEGER                                  :: np1, np2
 
-    REAL(real_8), PARAMETER                  :: wntau = 7.26e-7_real_8 
+    REAL(real_8), PARAMETER                  :: wntau = 7.26e-7_real_8
 
     INTEGER                                  :: i, ia, iat, imatch, intt, ip, &
                                                 ipp, is, j, k, l, m, n1, nc, &
@@ -226,6 +229,9 @@
           IF (cntl%tpath.AND.cntl%tpimd) THEN
              wnosep2 = (drnp*cntr%tempw/factem)**2
              IF ((pimd1%tpinm.OR.pimd1%tstage).AND.ip.EQ.1) wnosep2 = wnosep*wnosep
+             IF (pimd1%tringp.AND.pimd1%tpinm.AND.ip.GT.1) wnosep2 = wnosep2*flnm(ip)
+             IF (pimd1%tcentro.AND.(pimd1%tpinm.OR.pimd1%tstage)&
+                 .AND.ip.GT.1) wnosep2 = wnosep2*pimd2%facstage
              ipp=MIN(ip,2)
              ! DM1
              ! ..Classical test
@@ -367,23 +373,43 @@
                      WRITE(6,'(A,A)')&
                      '    NO THERMOSTAT ON FIRST BEAD  IP=1 '
                 ELSE 
-                   wdum=wnosep/wntau
+                   wdum=wnosep/(wntau*2._real_8*pi)
                    IF (paral%io_parent)&
                      WRITE(6,'(A,F9.2,A)')&
                      '    CHARACTERISTIC FREQUENCY FOR IP=1 :',wdum,' CM**-1 (SINGLE)'
                 ENDIF
-                wdum=(drnp*cntr%tempw/factem)/wntau
+                wdum=(drnp*cntr%tempw/factem*SQRT(pimd2%facstage))/(wntau*2._real_8*pi)
                 IF (paral%io_parent)&
                      WRITE(6,'(A,F9.2,A)')&
                      '    CHARACTERISTIC FREQUENCY FOR IP>1 :',wdum,' CM**-1 '
+             ELSE IF (pimd1%tringp) THEN
+                IF (paral%io_parent)&
+                     WRITE(6,'(A,A)') ' FOR NORMAL MODE PROPAGATOR',&
+                     ' WITH RING-POLYMER DYNAMICS'
+                IF (.NOT.tnosepc) THEN
+                   IF (paral%io_parent)&
+                     WRITE(6,'(A,A)')&
+                     '    NO THERMOSTAT ON FIRST BEAD  IP=1 '
+                ELSE
+                   wdum=wnosep/(wntau*2._real_8*pi)
+                   IF (paral%io_parent)&
+                     WRITE(6,'(A,F9.2,A)')&
+                     '    CHARACTERISTIC FREQUENCY FOR IP=1 :',wdum,' CM**-1 '
+                ENDIF
+                DO ip=2,pimd3%np_total
+                   wdum=(drnp*cntr%tempw/factem*SQRT(flnm(ip)))/(wntau*2._real_8*pi)
+                   IF (paral%io_parent) &
+                   WRITE(6,'(A,I3,A,F9.2,A)') &
+                   '    CHARACTERISTIC FREQUENCY FOR IP=',ip ,':',wdum,' CM**-1 '
+                ENDDO
              ELSE
                 IF (paral%io_parent)&
                      WRITE(6,'(A)') ' FOR STAGING OR NORMAL MODE PROPAGATOR'
-                wdum=wnosep/wntau
+                wdum=wnosep/(wntau*2._real_8*pi)
                 IF (paral%io_parent)&
                      WRITE(6,'(A,F12.2,A)')&
                      '    CHARACTERISTIC FREQUENCY FOR IP=1 :',wdum,' CM**-1 '
-                wdum=(drnp*cntr%tempw/factem)/wntau
+                wdum=(drnp*cntr%tempw/factem)/(wntau*2._real_8*pi)
                 IF (paral%io_parent)&
                      WRITE(6,'(A,F12.2,A)')&
                      '    CHARACTERISTIC FREQUENCY FOR IP>1 :',wdum,' CM**-1 '
@@ -391,14 +417,19 @@
           ELSE
              IF (paral%io_parent)&
                   WRITE(6,'(A)') ' FOR PRIMITIVE PROPAGATOR'
-             wdum=(drnp*cntr%tempw/factem)/wntau
+             wdum=(drnp*cntr%tempw/factem)/(wntau*2._real_8*pi)
              IF (paral%io_parent)&
                   WRITE(6,'(A,F12.2,A)')&
                   '    CHARACTERISTIC FREQUENCY FOR IP=1 :',wdum,' CM**-1 '
-             wdum=(drnp*cntr%tempw/factem)/wntau
+             wdum=(drnp*cntr%tempw/factem)/(wntau*2._real_8*pi)
              IF (paral%io_parent)&
                   WRITE(6,'(A,F12.2,A)')&
                   '    CHARACTERISTIC FREQUENCY FOR IP>1 :',wdum,' CM**-1 '
+             IF (pimd1%tringp.AND..NOT.tnosepc) THEN
+                IF (paral%io_parent)&
+                    WRITE(6,'(A)')&
+                    '    WARNING FROM NOSEPA: CENTROIDOFF IS MEANINGFUL ONLY FOR NORMAL MODE PROPAGATOR'
+             ENDIF
           ENDIF
           IF (paral%io_parent)&
                WRITE(6,'(A,A)') ' *********************************',&
Index: src/pi_md_utils.mod.F90
===================================================================
--- src/pi_md_utils.mod.F90	(revision 4634)
+++ src/pi_md_utils.mod.F90	(revision 4635)
@@ -40,6 +40,13 @@
   USE getfnm_utils,                    ONLY: getfnm
   USE getfu_utils,                     ONLY: getfu
   USE getgyr_utils,                    ONLY: getgyration
+  USE glemod,                          ONLY: glepar,&
+                                             glec,&
+                                             gles,&
+                                             glet,&
+                                             glep
+  USE gle_utils,                       ONLY: gle_init,&
+                                             gle_step
   USE global_utils,                    ONLY: global
   USE ions,                            ONLY: ions1
   USE kinds,                           ONLY: real_8
@@ -71,20 +78,27 @@
   USE pimd,                            ONLY: &
        csumgv, csumrv, egcv, ehar, eharv, ehtv, ekinv, enlv, epseuv, eselfv, &
        esrv, etotv, excv, fionks, grandparent, ipcurr, maxnp, np_high, &
-       np_local, np_low, pimd1, pimd3, supergroup
+       np_local, np_low, pimd1, pimd3, supergroup, pma0s, pi_egle, pi_glec, &
+       pi_gles, pi_glet, pi_glep
   USE pinmtrans_utils,                 ONLY: pinmtrans
   USE pi_stress_utils,                 ONLY: pi_stress_vir,&
                                              pi_stress_pri,&
                                              pi_stress_nmm,&
                                              wr_pi_stress
+  USE pi_wf_utils,                     ONLY: initrep
   USE posupa_utils,                    ONLY: posupa
   USE posupi_utils,                    ONLY: posupi
   USE printave_utils,                  ONLY: paccd
   USE printp_utils,                    ONLY: printp
   USE prmem_utils,                     ONLY: prmem
+  USE prng,                            ONLY: prng_com,&
+                                             pi_prng_com
+  USE prng_utils,                      ONLY: prnginit,&
+                                             repprngu_vec
   USE prtgyr_utils,                    ONLY: prtgyr
   USE pslo,                            ONLY: pslo_com
   USE puttau_utils,                    ONLY: taucl
+  USE quenbo_utils,                    ONLY: quenbo
   USE ranp_utils,                      ONLY: ranp
   USE rattle_utils,                    ONLY: rattle
   USE readsr_utils,                    ONLY: xstring
@@ -91,9 +105,11 @@
   USE rekine_utils,                    ONLY: rekine
   USE reshaper,                        ONLY: reshape_inplace
   USE rhopri_utils,                    ONLY: rhopri
+  USE rinitwf_driver,                  ONLY: rinitwf
   USE rinvel_utils,                    ONLY: rinvel,&
                                              rvscal,&
                                              s_rinvel
+  USE rmas,                            ONLY: rmass
   USE ropt,                            ONLY: infi,&
                                              iteropt,&
                                              ropt_mod
@@ -110,7 +126,7 @@
   USE stagetrans_utils,                ONLY: stagetrans
   USE store_types,                     ONLY: &
        cprint, iprint_coor, iprint_force, irec_nop1, irec_nop2, irec_nop3, &
-       irec_nop4, restart1, rout1
+       irec_nop4, irec_wf, irec_prng, restart1, rout1
   USE strs,                            ONLY: paiu
   USE system,                          ONLY: &
        acc, cnti, cntl, cntr, maxsys, nacc, nacx, ncpw, restf
@@ -141,6 +157,7 @@
   PUBLIC :: pi_md
   PUBLIC :: pi_ener
   PUBLIC :: disten
+  PUBLIC :: gleback
 
 CONTAINS
 
@@ -162,11 +179,11 @@
     CHARACTER(len=30)                        :: tag
     COMPLEX(real_8), ALLOCATABLE             :: psi(:,:)
     INTEGER :: i, i1, i2, ierr, il_psi_1d, il_psi_2d, il_rhoe_1d, il_rhoe_2d, &
-      ip, ipx, isub, itemp, k, l, lscr, n1, n2, npx, nrepl, nwfc
+      ip, ipx, isub, itemp, k, l, lscr, n1, n2, npx, nrepl, nwfc, iprng0
     INTEGER, ALLOCATABLE                     :: irec(:,:)
     LOGICAL                                  :: ferror, reset_gkt, &
                                                 pitmnose(2)
-    REAL(real_8) :: accus(nacx,maxnp), d1, d2, disa(maxnp), dummies(1), &
+    REAL(real_8) :: accus(nacx,maxnp), d1, d2, disa(maxnp), dummies(maxnp), &
       dummy, econs(maxnp), econsa, eham(maxnp), ehama, ekin1, ekin2, ekina, &
       ekinc(maxnp), ekincp, ekinh1, ekinh2, ekinp, enose(maxnp), &
       enosp(maxnp), equant, etota, ff, glib_s, lmio(3), qpkinp, qvkinp, rnp, &
@@ -280,6 +297,29 @@
     CALL reshape_inplace(fion, (/3,maxsys%nax,maxsys%nsx, npx/), pifion)
     CALL reshape_inplace(taup, (/3,maxsys%nax,maxsys%nsx, npx/), pitaup)
     CALL reshape_inplace(velp, (/3,maxsys%nax,maxsys%nsx, npx/), pivelp)
+
+    ALLOCATE(pi_egle(npx),STAT=ierr)
+    IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+         __LINE__,__FILE__)
+    IF (np_local>1) THEN
+       ALLOCATE(pi_prng_com(np_local),STAT=ierr)
+       IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+            __LINE__,__FILE__)
+       IF (glepar%gle_mode>0) THEN
+          ALLOCATE(pi_glec(np_local),STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+               __LINE__,__FILE__)
+          ALLOCATE(pi_gles((glepar%gle_ns+1)*(glepar%gle_ns+1),np_local),STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+               __LINE__,__FILE__)
+          ALLOCATE(pi_glet((glepar%gle_ns+1)*(glepar%gle_ns+1),np_local),STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+               __LINE__,__FILE__)
+          ALLOCATE(pi_glep(3,maxsys%nax,maxsys%nsx,(glepar%gle_ns+1),np_local),STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'allocation problem',&
+               __LINE__,__FILE__)
+       ENDIF
+    ENDIF
     ! ==--------------------------------------------------------------==
     ! SCR ALLOCATION AND PARTITION (SCRATCH ARRAY).
     CALL rhoe_psi_size(il_psi_1d=il_psi_1d,il_psi_2d=il_psi_2d,&
@@ -308,52 +348,53 @@
     DO ipcurr=np_low,np_high
        nosl%tmnose=pitmnose(MIN(ipcurr,2))
        CALL read_irec(irec(:,ipcurr))
-       ! ..Construct filenames
-       cflbod='RESTART_'
-       IF (paral%io_parent)&
-            WRITE(cipnum,'(I4)') ipcurr
-       CALL xstring(cflbod,n1,n2)
-       CALL xstring(cipnum,i1,i2)
-       filbod=cflbod(n1:n2)//cipnum(i1:i2)//'.1'
-       IF (restart1%rlate) THEN
-          filn=filbod
-       ELSE
-          filn=cflbod(n1:n2)//cipnum(i1:i2)
-       ENDIF
-       ! ..Read restart file
-       ipx=ipcurr-np_low+1
-       CALL zhrwf(1,irec(:,ipcurr),c0(:,:,ipx:ipx),cm(:,:,ipx),crge%n,eigv(:,ipx),&
-            pitaup(:,:,:,ipcurr),&
-            pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),iteropt%nfi)
-       CALL dcopy(nacc,acc,1,accus(1,ipcurr),1)
-       IF (restart1%rgeo) THEN
-          IF (paral%io_parent) CALL geofile(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),'READ')
-          CALL mp_bcast(pitaup(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(pivelp(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
-          restart1%rvel=.TRUE.
-       ENDIF
-       ! ..Randomization of the atomic coordinates
-       IF (cntl%tranp.AND.paral%parent) CALL ranp(pitaup(:,:,:,ipcurr))
-       ! Read WF centers & spread from restart file
-       IF (vdwl%vdwd) THEN
-          IF (paral%io_parent) THEN
-             nwfc=crge%n
-             vdwwfl%trwannc=trwanncx(ipx)
-             CALL rwannier(nwfc,tauref(:,:,:,ipx),rwann(:,:,ipx),swann(:,ipx),&
-                  vdwwfl%trwannc)
-             IF (.NOT.vdwwfl%trwannc) THEN
-                CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),&
-                     1,tauref(1,1,1,ipx),1)
-             ENDIF
+       IF (restart1%restart) THEN
+          ! ..Construct filenames
+          cflbod='RESTART_'
+          IF (paral%io_parent)&
+               WRITE(cipnum,'(I4)') ipcurr
+          CALL xstring(cflbod,n1,n2)
+          CALL xstring(cipnum,i1,i2)
+          filbod=cflbod(n1:n2)//cipnum(i1:i2)//'.1'
+          IF (restart1%rlate) THEN
+             filn=filbod
+          ELSE
+             filn=cflbod(n1:n2)//cipnum(i1:i2)
           ENDIF
-          CALL mp_bcast(tauref(:,:,:,ipx),3*maxsys%nax*maxsys%nsx,&
-               parai%io_source,parai%cp_grp)
-          CALL mp_bcast(rwann(:,:,ipx),3*nwfcx*nfragx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(swann(:,ipx),nwfcx*nfragx,parai%io_source,parai%cp_grp)
-          CALL mp_bcast(vdwwfl%trwannc,parai%io_source,parai%cp_grp)
-          trwanncx(ipx)=vdwwfl%trwannc
+          ! ..Read restart file
+          ipx=ipcurr-np_low+1
+          CALL zhrwf(1,irec(:,ipcurr),c0(:,:,ipx:ipx),cm(:,:,ipx),crge%n,eigv(:,ipx),&
+               pitaup(:,:,:,ipcurr),&
+               pivelp(:,:,:,ipcurr),taui(:,:,:,ipcurr),iteropt%nfi)
+          CALL dcopy(nacc,acc,1,accus(1,ipcurr),1)
+          IF (restart1%rgeo) THEN
+             IF (paral%io_parent) CALL geofile(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),'READ')
+             CALL mp_bcast(pitaup(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
+             CALL mp_bcast(pivelp(:,:,:,ipcurr),3*maxsys%nax*maxsys%nsx,parai%io_source,parai%cp_grp)
+             restart1%rvel=.TRUE.
+          ENDIF
+          ! ..Randomization of the atomic coordinates
+          IF (cntl%tranp.AND.paral%parent) CALL ranp(pitaup(:,:,:,ipcurr))
+          ! ..Initialization of wavefunction
+          IF (irec(irec_wf,ipcurr).EQ.0) THEN
+             CALL rinitwf(c0(:,:,ipx:ipx),cm,sc0,crge%n,pitaup(:,:,:,ipcurr),&
+                  taur,rhoe,psi)
+             cntl%quenchb=.TRUE.
+          ENDIF
+          ! ..Store GLE-related variables
+          CALL gleback(ipcurr,.FALSE.,0)
        ENDIF
     ENDDO
+    ! ..Initialize replica coordinates if requested
+    IF (.NOT.restart1%restart) THEN
+       IF (pimd1%tinit) THEN
+          CALL initrep(pitaup)
+          cntl%quenchb=.TRUE.
+       ELSE
+          CALL stopgm(procedureN,'replica coordinates not read/generated',&
+             __LINE__,__FILE__)
+       ENDIF
+    ENDIF
     ! ..Global distribution of ionic positions
     CALL global(pitaup,3*maxsys%nax*maxsys%nsx)
     CALL mp_bcast(pitaup,SIZE(pitaup),parai%io_source,parai%cp_grp)
@@ -374,6 +415,35 @@
     DO ipcurr=np_low,np_high
        ipx=ipcurr-np_low+1
        CALL phfac(pitaup(:,:,:,ipcurr))
+       ! ..Read WF centers & spread from restart file
+       IF (vdwl%vdwd) THEN
+          IF (paral%io_parent) THEN
+             nwfc=crge%n
+             vdwwfl%trwannc=trwanncx(ipx)
+             CALL rwannier(nwfc,tauref(:,:,:,ipx),rwann(:,:,ipx),swann(:,ipx),&
+                  vdwwfl%trwannc)
+             IF (.NOT.vdwwfl%trwannc) THEN
+                CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),1,&
+                     tauref(1,1,1,ipx),1)
+             ENDIF
+          ENDIF
+          CALL mp_bcast(tauref(:,:,:,ipx),3*maxsys%nax*maxsys%nsx,&
+               parai%io_source,parai%cp_grp)
+          CALL mp_bcast(rwann(:,:,ipx),3*nwfcx*nfragx,parai%io_source,parai%cp_grp)
+          CALL mp_bcast(swann(:,ipx),nwfcx*nfragx,parai%io_source,parai%cp_grp)
+          CALL mp_bcast(vdwwfl%trwannc,parai%io_source,parai%cp_grp)
+          trwanncx(ipx)=vdwwfl%trwannc
+       ENDIF
+       ! ..Initialization of wavefunction
+       IF (.NOT.restart1%restart) THEN
+          CALL rinitwf(c0(:,:,ipx:ipx),cm,sc0,crge%n,pitaup(:,:,:,ipcurr),&
+               taur,rhoe,psi)
+       ENDIF
+       ! ..Quenching to BO surface
+       IF (cntl%quenchb) THEN
+          CALL dcopy(3*maxsys%nax*maxsys%nsx,pitaup(1,1,1,ipcurr),1,tau0,1)
+          CALL quenbo(c0(:,:,ipx),c2(1,1,ipx),sc0,taur,rhoe,psi)
+       ENDIF
        IF (pslo_com%tivan) THEN
           IF (cntl%tlsd) THEN
              CALL deort(ncpw%ngw,spin_mod%nsup,eigm(1,ipx),eigv(1,ipx),&
@@ -478,9 +548,9 @@
           IF (cntl%tnosep .AND. itemp.EQ.0) CALL nospinit(ipcurr)
           IF (cntl%tnosee .AND. .NOT.restart1%rnoe) CALL noseinit(ipcurr)
           ! DM1
-          ! ..Centroid PICPMD: Set thermostat variables to zero in case 
+          ! ..Centroid & Ring-polymer PICPMD: Set thermostat variables to zero in case 
           ! ..of a centroid restart from a non-centroid thermosatted run
-          IF (cntl%tnosep.AND.pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF (cntl%tnosep.AND.(pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              nrepl=maxnp
              IF (nosl%tultra) THEN
                 ! ..Not used with PICPMD 
@@ -488,14 +558,20 @@
                 CALL stopgm('PI_MD','LOCAL TEMEPERATURE NOT IMPLEMENTED',& 
                      __LINE__,__FILE__)
              ELSEIF (nosl%tmnose) THEN
-                CALL stopgm(procedureN,'Massive NHCs thermostat not available for ip=1',&
-                     __LINE__,__FILE__)
-             !  DO k=1,3*maxsys%nax*maxsys%nsx
-             !     DO l=1,nchx
-             !        etapm(k,l,1)=0._real_8
-             !        etapmdot(k,l,1)=0._real_8
-             !     ENDDO
-             !  ENDDO
+                IF (pimd1%tcentro) THEN
+                   CALL stopgm(procedureN,'Massive NHCs thermostat not available for ip=1',&
+                        __LINE__,__FILE__)
+                ELSE
+                   ! ..Switch off if requested
+                   IF (.NOT.tnosepc) THEN
+                      DO k=1,3*maxsys%nax*maxsys%nsx
+                         DO l=1,nchx
+                            etapm(k,l,1)=0._real_8
+                            etapmdot(k,l,1)=0._real_8
+                         ENDDO
+                      ENDDO
+                   ENDIF
+                ENDIF
              ELSE
                 ! ..Switch off if requested
                 IF (.NOT.tnosepc) THEN
@@ -509,6 +585,27 @@
           ! DM2
        ENDDO
     ENDIF
+
+    ! Initialize GLE thermostat
+    iprng0=cnti%iprng
+    CALL repprngu_vec(npx,dummies)
+    DO ipcurr=np_low,np_high
+       ipx=ipcurr-np_low+1
+       CALL gleback(ipcurr,.FALSE.,1)
+       IF (.NOT.restart1%rprng.OR.irec(irec_prng,ipcurr).EQ.0) THEN
+          cnti%iprng=FLOOR(dummies(ipcurr)*iprng0)
+          IF (paral%io_parent) WRITE(6,*) 'USING SEED ', cnti%iprng,&
+             'TO REINIT. PSEUDO RANDOM NUMBER GEN.'
+          CALL prnginit
+       ENDIF
+       IF (pimd1%tstage.OR.pimd1%tpinm) THEN
+          CALL gle_init(stagep(:,:,:,ipcurr),vstage(:,:,:,ipcurr),pma0s(1,ipcurr))
+       ELSE
+          CALL gle_init(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),rmass%pma)
+       ENDIF
+       CALL gleback(ipcurr,.TRUE.,0)
+    ENDDO
+
     IF (grandparent) THEN
        IF (pimd3%levprt.GE.5) THEN
           DO ip=1,pimd3%np_total
@@ -569,7 +666,15 @@
              CALL noseup(pivelp(:,:,:,ipcurr),cm(1,1,ipx),crge%n,ipcurr)
           ENDIF
           IF (reset_gkt.AND.ipcurr==1) gkt(1:2,1)=scr(1:2)
-          IF (pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          ! FIRST HALF OF GLE EVOLUTION
+          CALL gleback(ipcurr,.TRUE.,1)
+          IF (pimd1%tstage.OR.pimd1%tpinm) THEN
+             CALL gle_step(stagep(:,:,:,ipcurr),vstage(:,:,:,ipcurr),pma0s(1,ipcurr))
+          ELSE
+             CALL gle_step(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),rmass%pma)
+          ENDIF
+          CALL gleback(ipcurr,.TRUE.,0)
+          IF ((pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              IF (pimd1%tstage.OR.pimd1%tpinm) THEN
                 ! SUBTRACT CENTER OF MASS VELOCITY
                 IF (paral%parent.AND.comvl%subcom) THEN
@@ -740,7 +845,7 @@
                 ! DM2ra
              ENDIF
           ENDIF
-          IF (pimd1%tcentro.AND.ipcurr.EQ.1) THEN
+          IF ((pimd1%tcentro.OR.pimd1%tringp).AND.ipcurr.EQ.1) THEN
              IF (pimd1%tstage.OR.pimd1%tpinm) THEN
                 ! SUBTRACT ROTATION AROUND CENTER OF MASS
                 IF (paral%parent.AND.comvl%subrot) THEN
@@ -752,6 +857,14 @@
                 ENDIF
              ENDIF
           ENDIF
+          ! SECOND HALF OF GLE EVOLUTION
+          CALL gleback(ipcurr,.TRUE.,1)
+          IF (pimd1%tstage.OR.pimd1%tpinm) THEN
+              CALL gle_step(stagep(:,:,:,ipcurr),vstage(:,:,:,ipcurr),pma0s(1,ipcurr))
+          ELSE
+              CALL gle_step(pitaup(:,:,:,ipcurr),pivelp(:,:,:,ipcurr),rmass%pma)
+          ENDIF
+          CALL gleback(ipcurr,.TRUE.,0)
           ! ..UPDATE NOSE THERMOSTATS
           IF (cntl%tnosee.OR.cntl%tc) CALL rekine(cm(1,1,ipx),crge%n,ekinc(ipcurr))
           nosl%tmnose=pitmnose(MIN(ipcurr,2))
@@ -812,7 +925,7 @@
              ! DM2
              econs(ipcurr)=ekinp+etotv(ipcurr)/rnp+&
                   enose(ipcurr)/rnp+enosp(ipcurr)+&
-                  eharv(ipcurr)+ener_com%ecnstr+ener_com%erestr
+                  eharv(ipcurr)+ener_com%ecnstr+ener_com%erestr+pi_egle(ipcurr)
              eham(ipcurr)=econs(ipcurr)+ekinc(ipcurr)/rnp
           ENDIF
        ENDDO
@@ -837,6 +950,7 @@
        CALL global(ekinc,1)
        CALL global(enose,1)
        CALL global(enosp,1)
+       CALL global(pi_egle,1)
        CALL global(disa,1)
        ! DM C..PRINTOUT the evolution of the accumulators every time step
        IF (grandparent) THEN
@@ -865,14 +979,14 @@
              CALL prtgyr
              IF (paral%io_parent)&
                   WRITE(6,'(/,A,A)')&
-                  '    NFI   IP   EKINC  TEMPP     EHARM         EKS',&
-                  '    ENOSE(E)  ENOSE(P)    ECLASSIC        EHAM     DIS'
+                  '      NFI   IP   EKINC  TEMPP     EHARM         EKS',&
+                  '    ENOSE(E)  ENOSE(P)      EGLE    ECLASSIC        EHAM     DIS'
              DO ip=1,pimd3%np_total
                 IF (paral%io_parent)&
                      WRITE(6,&
-                     '(I7,I5,F8.5,F7.1,F10.6,F12.5,2X,2F10.5,2F12.5,F8.2)')&
+                     '(I9,I5,F8.5,F7.1,F10.6,F12.5,2X,3F10.5,2F12.5,F8.2)')&
                      iteropt%nfi,ip,ekinc(ip),tempp(ip),eharv(ip),etotv(ip),&
-                     enose(ip),enosp(ip),econs(ip),eham(ip),disa(ip)
+                     enose(ip),enosp(ip),pi_egle(ip),econs(ip),eham(ip),disa(ip)
              ENDDO
           ENDIF
           ! ..Quantum kinetic energy of ions
@@ -905,13 +1019,13 @@
           tcpu=(time2-time1)*0.001_real_8
           IF ((ropt_mod%engpri).AND.paral%io_parent)&
                WRITE(6,'(/,A,A)')&
-               '    NFI  EKINC/P  TEMP   EKINP(PRI)  EKINP(VIR)      EKS/P ',&
+               '      NFI  EKINC/P  TEMP   EKINP(PRI)  EKINP(VIR)      EKS/P ',&
                '     EQUANT    ECLASSIC        EHAM     TCPU'
           IF (paral%io_parent)&
-               WRITE(6,'(I7,F8.5,F7.1,6F12.5,F9.2)')&
+               WRITE(6,'(I9,F8.5,F7.1,6F12.5,F9.2)')&
                iteropt%nfi,ekina,tempa,qpkinp,qvkinp,etota,equant,econsa,ehama,tcpu
           IF (paral%io_parent)&
-               WRITE(3,'(I7,F15.10,F7.1,6F20.10,F9.2)')&
+               WRITE(3,'(I9,F15.10,F7.1,6F20.10,F9.2)')&
                iteropt%nfi,ekina,tempa,qpkinp,qvkinp,etota,equant,econsa,ehama,tcpu
           ! ..Store ionic coordinates and velocities for statistics
           ropt_mod%movie=rout1%mout .AND. MOD(iteropt%nfi-1,cnti%imovie).EQ.0
@@ -931,7 +1045,7 @@
        IF (infi.EQ.cnti%nomore) soft_com%exsoft=.TRUE.
        ! new
        nosl%tmnose=pitmnose(2)  ! recover original setup of tmnose
-       IF ((pimd1%tstage.OR.pimd1%tpinm).AND.nosl%tmnose) CALL wr_temps(iteropt%nfi,ekinc,tempp)
+       IF (pimd1%tstage.OR.pimd1%tpinm) CALL wr_temps(iteropt%nfi,ekinc,tempp)
        ! new
        IF (ropt_mod%calste) THEN
           IF (pimd1%tstage.OR.pimd1%tpinm) THEN
@@ -968,6 +1082,7 @@
           ipx=ipcurr-np_low+1
           CALL dcopy(nacc,accus(1,ipcurr),1,acc,1)
           IF (teststore(infi).OR.soft_com%exsoft) THEN
+             CALL gleback(ipcurr,.FALSE.,1)
              nosl%tmnose=pitmnose(MIN(ipcurr,2))
              CALL write_irec(irec(:,ipcurr))
              CALL zhwwf(2,irec(:,ipcurr),c0(:,:,ipx),cm(:,:,ipx),crge%n,eigv(:,ipx),&
@@ -1019,6 +1134,28 @@
        DEALLOCATE(fstage,STAT=ierr)
        IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
             __LINE__,__FILE__)
+    ENDIF 
+    DEALLOCATE(pi_egle,STAT=ierr)
+    IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+         __LINE__,__FILE__)
+    IF (np_local>1) THEN
+       DEALLOCATE(pi_prng_com,STAT=ierr)
+       IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+            __LINE__,__FILE__)
+       IF (glepar%gle_mode>0) THEN
+          DEALLOCATE(pi_glec,STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+               __LINE__,__FILE__)
+          DEALLOCATE(pi_gles,STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+               __LINE__,__FILE__)
+          DEALLOCATE(pi_glet,STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+               __LINE__,__FILE__)
+          DEALLOCATE(pi_glep,STAT=ierr)
+          IF(ierr/=0) CALL stopgm(procedureN,'deallocation problem',&
+               __LINE__,__FILE__)
+       ENDIF
     ENDIF
     IF (comvl%tsubrot) THEN
        DEALLOCATE(tauio,STAT=ierr)
@@ -1053,7 +1190,7 @@
     ! ==--------------------------------------------------------------==
     INTEGER                                  :: ipc, iflg
 
-! ==--------------------------------------------------------------==
+    ! ==--------------------------------------------------------------==
 
     IF (iflg.EQ.0) THEN
        etotv(ipc)   = ener_com%etot
@@ -1103,5 +1240,44 @@
     RETURN
   END SUBROUTINE disten
   ! ==================================================================
+  SUBROUTINE gleback(ipc,tback,iflg)
+    ! ==--------------------------------------------------------------==
+    ! == Save or restore variables of PRNG and GLE for PIMD           ==
+    ! == iflg 0 -> SAVE                                               ==
+    ! ==      1 -> RESTORE                                            ==
+    ! ==--------------------------------------------------------------==
+    IMPLICIT NONE
+    INTEGER                                  :: ipc, iflg
+    LOGICAL                                  :: tback
+    INTEGER                                  :: ipx
 
+    ipx=ipc-np_low+1
+    IF (iflg==0) THEN
+       pi_egle(ipc)=glepar%egle
+       IF (np_local>1) THEN
+          pi_prng_com(ipx)=prng_com
+          IF (glepar%gle_mode>0) THEN
+             IF (tback) pi_glec(ipx)=glec(1)
+             IF (tback) pi_gles(:,ipx)=gles(:)
+             IF (tback) pi_glet(:,ipx)=glet(:)
+             pi_glep(:,:,:,:,ipx)=glep(:,:,:,:)
+          ENDIF
+       ENDIF
+    ELSE
+       glepar%egle=pi_egle(ipc)
+       IF (np_local>1) THEN
+          prng_com=pi_prng_com(ipx)
+          IF (glepar%gle_mode>0) THEN
+             IF (tback) glec(1)=pi_glec(ipx)
+             IF (tback) gles(:)=pi_gles(:,ipx)
+             IF (tback) glet(:)=pi_glet(:,ipx)
+             glep(:,:,:,:)=pi_glep(:,:,:,:,ipx)
+          ENDIF
+       ENDIF
+    ENDIF
+    ! ==--------------------------------------------------------------==
+    RETURN
+  END SUBROUTINE gleback
+  ! ==================================================================
+
 END MODULE pi_md_utils
Index: src/pi_init_utils.mod.F90
===================================================================
--- src/pi_init_utils.mod.F90	(revision 4634)
+++ src/pi_init_utils.mod.F90	(revision 4635)
@@ -1,7 +1,11 @@
 MODULE pi_init_utils
   USE adat,                            ONLY: elem
-  USE cnst,                            ONLY: scmass
+  USE cnst,                            ONLY: scmass,&
+                                             factem
   USE error_handling,                  ONLY: stopgm
+  USE glemod,                          ONLY: glepar,&
+                                             icm2au,&
+                                             tglepc
   USE ions,                            ONLY: ions0,&
                                              ions1
   USE kinds,                           ONLY: real_8
@@ -11,7 +15,7 @@
   USE pimd,                            ONLY: &
        fcorr, flnm, grandparent, ifcorr, ircorr, maxnp, pcg_pos, pimd1, &
        pimd2, pimd3, pma0s, pmar, pmar0, pmars, rcor, rcora, rcorr, rgyr, &
-       rgyra, rsus, rsusa, tnm, tnmi
+       rgyra, rsus, rsusa, tnm, tnmi, pi_omega
   USE rmas,                            ONLY: rmass
   USE system,                          ONLY: cntr,&
                                              maxsys
@@ -235,6 +239,43 @@
           ! DM2
        ENDDO
     ENDIF
+    ! MASS SETTINGS FOR RING-POLYMER DYNAMICS
+    IF (pimd1%tringp) THEN
+       npx=pimd3%np_total
+       rnp=REAL(npx,kind=real_8)
+
+       rmass%pmat0=0._real_8
+       rmass%pmatot=0._real_8
+       DO is=1,ions1%nsp
+          ! STORE REAL IONIC MASS (IN CHEMICAL UNITS) IN PMAR0
+          pmar0(is)=rmass%pma0(is)
+          ! STORE REAL IONIC MASS (IN ATOMIC UNITS) IN PMAR
+          pmar(is)=pmar0(is)*scmass
+          ! STORE FICTITIOUS IONIC MASS (IN CHEMICAL UNITS) IN PMA0
+          rmass%pma0(is)=pmar0(is)/rnp
+          ! STORE TOTAL FICTITIOUS MASS (IN CHEMICAL UNITS) IN PMAT0
+          rmass%pmat0=rmass%pmat0+rmass%pma0(is)*ions0%na(is)
+          ! STORE FICTITIOUS IONIC MASS (IN ATOMIC UNITS) IN PMA
+          rmass%pma(is)=rmass%pma0(is)*scmass
+          ! STORE TOTAL FICTITIOUS MASS (IN ATOMIC UNITS) IN PMATOT
+          rmass%pmatot=rmass%pmatot+rmass%pma(is)*ions0%na(is)
+       ENDDO
+       IF (pimd1%tpinm) THEN
+          ! MASS SETTINGS FOR NORMAL MODE REPRESENTATION
+          ! NORMAL MODE TRAFO FOR REAL PHYSICAL MASSES (FOR POTENTIAL ENERGY)
+          DO is=1,ions1%nsp
+             pmars(is,1)=pmar(is)
+             DO ip=2,npx
+                pmars(is,ip)=pmar(is)*flnm(ip)
+             ENDDO
+             ! FICTITIOUS NORMAL MODE MASSES (FOR FICTICIOUS KINETIC ENERGY)
+             ! ARE PHYSICAL MASSES FOR ALL NORMAL MODES
+             DO ip=1,npx
+                pma0s(is,ip)=pmar(is)
+             ENDDO
+          ENDDO
+       ENDIF
+    ENDIF
     ! DM1
     ! ..print detailed information about final mass settings in PI case
     IF (grandparent) THEN
@@ -321,6 +362,28 @@
        IF (wan05%loc_npgrp>parai%cp_nproc) wan05%loc_npgrp=parai%cp_nproc
     ENDIF
 
+    ! Friction coefficient for GLE thermostat
+    IF (glepar%gle_mode>0) THEN
+       npx=pimd3%np_total
+       rnp=REAL(npx,kind=real_8)
+       DO ip=1,npx
+          pi_omega(ip)=2._real_8*SQRT(rnp)*cntr%tempw/factem*pimd2%gle_lambda/icm2au
+          IF ((pimd1%tpinm.OR.pimd1%tstage).AND.ip.EQ.1) THEN
+             IF ((pimd1%tcentro.OR.pimd1%tringp).AND..NOT.tglepc) THEN
+                pi_omega(ip) = 0._real_8
+             ELSE
+                pi_omega(ip) = 2._real_8*glepar%gle_omega*pimd2%gle_lambda
+             ENDIF
+          ENDIF
+          IF (pimd1%tringp.AND.pimd1%tpinm.AND.ip.GT.1) THEN
+             pi_omega(ip) = pi_omega(ip)*SQRT(flnm(ip))
+          ENDIF
+          IF (pimd1%tcentro.AND.(pimd1%tpinm.OR.pimd1%tstage).AND.ip.GT.1) THEN
+             pi_omega(ip) = pi_omega(ip)*SQRT(pimd2%facstage)
+          ENDIF
+       ENDDO
+    ENDIF
+ 
     CALL tihalt(procedureN,isub)
     RETURN
   END SUBROUTINE pi_init
Index: src/pimd.mod.F90
===================================================================
--- src/pimd.mod.F90	(revision 4634)
+++ src/pimd.mod.F90	(revision 4635)
@@ -10,8 +10,8 @@
   ! == !! NOTE: IF YOU ADD ITEMS TO THE COMMON BLOCKS INCREASE THE  ==
   ! ==          RESPECTIVE PARAMETERS PI_LOG,PI_REL,PI_INT          ==
   ! ==================================================================
-  INTEGER, PARAMETER :: pi_log=9 
-  INTEGER, PARAMETER :: pi_rel=4 
+  INTEGER, PARAMETER :: pi_log=10
+  INTEGER, PARAMETER :: pi_rel=5 
   INTEGER, PARAMETER :: pi_int=4 
   ! ==--------------------------------------------------------------==
   ! == PILOG       Only for broadcasting                            ==
@@ -34,6 +34,7 @@
   ! == TCENTRO     Do centroid path integral MD and                 ==
   ! ==             do not thermostat centroid mode,                 ==
   ! ==             i.e., first Trotter slice                        ==
+  ! == TRINGP      Do ring-polymer path integral MD                 ==
   ! == TESTPI      Classical path integral test                     ==
   ! ==--------------------------------------------------------------==
 
@@ -55,6 +56,9 @@
   ! ==             The fictitious non-centroid masses are           ==
   ! ==             FACSTAGE times lighter than the centroid mass    ==
   ! ==             (which has the physical mass as fictitious mass) ==
+  ! == GLE_LAMBDA  Friction coefficient of GLE thermostat is        ==
+  ! ==             GLE_LAMBDA times larger than the frequency       ==
+  ! ==             of the harmonic potential                        ==
   ! ==--------------------------------------------------------------==
 
   ! ==--------------------------------------------------------------==
@@ -195,6 +199,13 @@
   REAL(real_8), ALLOCATABLE :: fcorr(:,:,:)
 
 
+  REAL(real_8) :: pi_omega(maxnp)
+  REAL(real_8), ALLOCATABLE :: pi_egle(:)
+  REAL(real_8), ALLOCATABLE :: pi_glec(:)
+  REAL(real_8), ALLOCATABLE :: pi_gles(:,:)
+  REAL(real_8), ALLOCATABLE :: pi_glet(:,:)
+  REAL(real_8), ALLOCATABLE :: pi_glep(:,:,:,:,:)
+
   ! ==================================================================
 
   TYPE :: pimd1_t
@@ -206,6 +217,7 @@
      LOGICAL :: tinit
      LOGICAL :: repread
      LOGICAL :: tcentro
+     LOGICAL :: tringp
      LOGICAL :: testpi
   END TYPE pimd1_t
   TYPE(pimd1_t) :: pimd1
@@ -214,6 +226,7 @@
      REAL(real_8) :: tempb
      REAL(real_8) :: wmass
      REAL(real_8) :: facstage
+     REAL(real_8) :: gle_lambda
   END TYPE pimd2_t
   TYPE(pimd2_t) :: pimd2
   TYPE :: pimd3_t
Index: src/control_utils.mod.F90
===================================================================
--- src/control_utils.mod.F90	(revision 4634)
+++ src/control_utils.mod.F90	(revision 4635)
@@ -33,7 +33,7 @@
                                              glocr
   USE glemod,                          ONLY: &
        gle_cp_ns, gle_cpmd, gle_cust, gle_opt, gle_opt_ns, gle_smart, &
-       gle_smart_ns, gle_white, glepar
+       gle_smart_ns, gle_white, glepar, tglepc
   USE header_utils,                    ONLY: header
   USE hubbardu,                        ONLY: hubbu
   USE inscan_utils,                    ONLY: inscan
@@ -1185,6 +1185,7 @@
                 CALL readsi(line,first,last,cnti%iprng,erread)
              ELSEIF ( keyword_contains(line,'LANGEVIN') ) THEN
                 IF ( keyword_contains(line,'MOVECM',alias='MOVECOM')) glepar%gle_com=0
+                IF ( keyword_contains(line,'CENTROIDOFF')) tglepc=.FALSE.
                 IF ( keyword_contains(line,'WHITE') ) THEN
                    glepar%gle_mode=gle_white
                    glepar%gle_ns=0
@@ -3439,7 +3440,7 @@
              ELSEIF ( keyword_contains(line,'RHOOUT') ) THEN
                 ! Store density
                 rout1%rhoout=.TRUE.
-                IF ( keyword_contains(line,'SAMPLE',cut_at='=') ) THEN
+                IF ( keyword_contains(line,'SAMPLE') ) THEN
                    first = index_of_delimiter(line,'SAMPLE','=')
                    CALL readsi(line,first,last,rout1%nrhoout,erread)
                    IF (erread) THEN
Index: src/gle.mod.F90
===================================================================
--- src/gle.mod.F90	(revision 4634)
+++ src/gle.mod.F90	(revision 4635)
@@ -8,8 +8,7 @@
   INTEGER :: gle_ns, gle_mode, gle_com
   REAL(real_8), PARAMETER :: gle_omega_def=2000.0_real_8, icm2au=4.5563353e-06_real_8 
 
-
-
+  LOGICAL :: tglepc
   REAL(real_8), ALLOCATABLE :: glea(:), glec(:), gles(:), glet(:),&
        glep(:,:,:,:)
 
Index: configure/Oakforest-PACS-INTEL-FFTW
===================================================================
--- configure/Oakforest-PACS-INTEL-FFTW	(nonexistent)
+++ configure/Oakforest-PACS-INTEL-FFTW	(revision 4635)
@@ -0,0 +1,41 @@
+#INFO#
+#INFO# Configuration for Oakforest-PACS (Fujitsu) to build a parallel 
+#INFO# cpmd executable using Intel Fortran compiler version 18 or later, 
+#INFO# Intel MPI, MKL, and FFTW supplied by Fujitsu as a module.
+#INFO# See https://insidehpc.com/2016/12/oakforest-pacs/
+#INFO#     https://www.top500.org/system/178932
+#INFO# WARNING: PIMD jobs are observed to crush sometimes (not always, just randomly) 
+#INFO#          if the code is compiled without including -D__HASNT_OMP_COLLAPSE 
+#INFO#          in CPPFLAGS. Most likely this is a compiler bug / side-effects of 
+#INFO#          loop collapsing. Hopefully this will be solved in forthcoming
+#INFO#          compiler updates.
+
+     IRAT=2
+     FC='mpiifort'
+     CC='mpiicc'
+     LD='mpiifort'
+     FFLAGS_GROMOS='$(FFLAGS) -fixed'
+     FFLAGS_GROMOS_MODULES='$(FFLAGS)'
+     CPP='/usr/bin/cpp -E -P -traditional'
+     CPPFLAGS='-D__Linux -D__INTEL -D__HAS_FFT_FFTW3 -D__PARALLEL -DLINUX_IFC \
+               -D__HASNT_OMP_45 -D__HASNT_OMP_COLLAPSE -D__HAS_LIBXC'
+     AR='/usr/bin/ar ruv'
+     RANLIB='/usr/bin/ranlib'
+     if [ $debug ]; then
+       FFLAGS='-g -O0 -axMIC-AVX512 -pc64 -align array64byte \
+               -I${HOME}/lib/libxc/include \
+               -gen_interfaces -traceback -check all,noarg_temp_created'
+       CFLAGS='-g -O0'
+     else
+       FFLAGS='-O2 -axMIC-AVX512 -pc64 -align array64byte \
+               -I${HOME}/lib/libxc/include'
+       CFLAGS='-O2'
+     fi
+     if [ $omp ]; then
+       FFLAGS=${FFLAGS}' -qopenmp'
+       LIBS='-mkl=parallel -L${HOME}/lib/libxc/lib -lxcf03 -lxc -lfftw3_omp -lfftw3'
+       OMP3_DISABLED=`{ ${FC} -v; } 2>&1 | ${AWK} '{ print ( $2 < "12.0.4" ) ? "true" : "false" }'`
+     else
+       LIBS='-mkl=sequential -L${HOME}/lib/libxc/lib -lxcf03 -lxc -lfftw3'
+     fi
+     LFLAGS='-static-intel '${LIBS}
